#include <assert.h>
#include <setjmp.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdarg.h>

/* required for sandboxing */
#include <sys/types.h>
#include <sys/stat.h>

#ifdef _WIN32
#	include <windows.h>
#	include <io.h>
#	include <shellapi.h>
#	include <direct.h>

#	define _MAIN_CC __cdecl

#	define stat(path, st) _stat(path, st)
#	define mkdir(path, mode) _mkdir(path)
#	define chdir(path) _chdir(path)
#	define access(path, mode) _access(path, mode)
#	define strdup(str) _strdup(str)
#	define strcasecmp(a,b) _stricmp(a,b)

#	ifndef __MINGW32__
#		pragma comment(lib, "shell32")
#		define strncpy(to, from, to_size) strncpy_s(to, to_size, from, _TRUNCATE)
#		define W_OK 02
#		define S_ISDIR(x) ((x & _S_IFDIR) != 0)
#		define snprint_eq(buf,sz,fmt,a,b) _snprintf_s(buf,sz,_TRUNCATE,fmt,a,b)
#	else
#		define snprint_eq snprintf
#	endif
	typedef struct _stat STAT_T;
#else
#	include <sys/wait.h> /* waitpid(2) */
#	include <unistd.h>
#	define _MAIN_CC
#	define snprint_eq snprintf
	typedef struct stat STAT_T;
#endif

#include "clar.h"

static void fs_rm(const char *_source);
static void fs_copy(const char *_source, const char *dest);

static const char *
fixture_path(const char *base, const char *fixture_name);

struct clar_error {
	const char *test;
	int test_number;
	const char *suite;
	const char *file;
	int line_number;
	const char *error_msg;
	char *description;

	struct clar_error *next;
};

static struct {
	const char *active_test;
	const char *active_suite;

	int suite_errors;
	int total_errors;

	int test_count;

	int report_errors_only;
	int exit_on_error;

	struct clar_error *errors;
	struct clar_error *last_error;

	void (*local_cleanup)(void *);
	void *local_cleanup_payload;

	jmp_buf trampoline;
	int trampoline_enabled;
} _clar;

struct clar_func {
	const char *name;
	void (*ptr)(void);
};

struct clar_suite {
	int index;
	const char *name;
	struct clar_func initialize;
	struct clar_func cleanup;
	const char **categories;
	const struct clar_func *tests;
	size_t test_count;
};

/* From clar_print_*.c */
static void clar_print_init(int test_count, int suite_count, const char *suite_names);
static void clar_print_shutdown(int test_count, int suite_count, int error_count);
static void clar_print_error(int num, const struct clar_error *error);
static void clar_print_ontest(const char *test_name, int test_number, int failed);
static void clar_print_onsuite(const char *suite_name, int suite_index);
static void clar_print_onabort(const char *msg, ...);

/* From clar_sandbox.c */
static void clar_unsandbox(void);
static int clar_sandbox(void);

/* From clar_categorize.c */
static int clar_category_is_suite_enabled(const struct clar_suite *);
static void clar_category_enable(const char *category);
static void clar_category_enable_all(size_t, const struct clar_suite *);
static void clar_category_print_enabled(const char *prefix);

/* Event callback overrides */
#define clar_on_test() /* nop */
#define clar_on_suite() /* nop */

/* Autogenerated test data by clar */
static const struct clar_func _clar_cb_attr_file[] = {
    {"assign_variants", &test_attr_file__assign_variants},
	{"check_attr_examples", &test_attr_file__check_attr_examples},
	{"match_variants", &test_attr_file__match_variants},
	{"simple_read", &test_attr_file__simple_read}
};
static const struct clar_func _clar_cb_attr_flags[] = {
    {"bare", &test_attr_flags__bare},
	{"index_vs_workdir", &test_attr_flags__index_vs_workdir},
	{"subdir", &test_attr_flags__subdir}
};
static const struct clar_func _clar_cb_attr_lookup[] = {
    {"assign_variants", &test_attr_lookup__assign_variants},
	{"check_attr_examples", &test_attr_lookup__check_attr_examples},
	{"from_buffer", &test_attr_lookup__from_buffer},
	{"match_variants", &test_attr_lookup__match_variants},
	{"simple", &test_attr_lookup__simple}
};
static const struct clar_func _clar_cb_attr_repo[] = {
    {"bad_macros", &test_attr_repo__bad_macros},
	{"foreach", &test_attr_repo__foreach},
	{"get_many", &test_attr_repo__get_many},
	{"get_one", &test_attr_repo__get_one},
	{"macros", &test_attr_repo__macros},
	{"manpage_example", &test_attr_repo__manpage_example},
	{"staging_properly_normalizes_line_endings_according_to_gitattributes_directives", &test_attr_repo__staging_properly_normalizes_line_endings_according_to_gitattributes_directives}
};
static const struct clar_func _clar_cb_buf_basic[] = {
    {"printf", &test_buf_basic__printf},
	{"resize", &test_buf_basic__resize}
};
static const struct clar_func _clar_cb_buf_splice[] = {
    {"append", &test_buf_splice__append},
	{"dont_do_anything", &test_buf_splice__dont_do_anything},
	{"insert_at", &test_buf_splice__insert_at},
	{"preprend", &test_buf_splice__preprend},
	{"remove_at", &test_buf_splice__remove_at},
	{"replace", &test_buf_splice__replace},
	{"replace_with_longer", &test_buf_splice__replace_with_longer},
	{"replace_with_shorter", &test_buf_splice__replace_with_shorter},
	{"truncate", &test_buf_splice__truncate}
};
static const struct clar_func _clar_cb_checkout_head[] = {
    {"checking_out_an_orphaned_head_returns_GIT_EORPHANEDHEAD", &test_checkout_head__checking_out_an_orphaned_head_returns_GIT_EORPHANEDHEAD}
};
static const struct clar_func _clar_cb_checkout_index[] = {
    {"calls_progress_callback", &test_checkout_index__calls_progress_callback},
	{"can_create_missing_files", &test_checkout_index__can_create_missing_files},
	{"can_notify_of_skipped_files", &test_checkout_index__can_notify_of_skipped_files},
	{"can_overcome_name_clashes", &test_checkout_index__can_overcome_name_clashes},
	{"can_overwrite_modified_file", &test_checkout_index__can_overwrite_modified_file},
	{"can_remove_untracked_files", &test_checkout_index__can_remove_untracked_files},
	{"cannot_checkout_a_bare_repository", &test_checkout_index__cannot_checkout_a_bare_repository},
	{"donot_overwrite_modified_file_by_default", &test_checkout_index__donot_overwrite_modified_file_by_default},
	{"honor_coreautocrlf_setting_set_to_true", &test_checkout_index__honor_coreautocrlf_setting_set_to_true},
	{"honor_coresymlinks_setting_set_to_false", &test_checkout_index__honor_coresymlinks_setting_set_to_false},
	{"honor_coresymlinks_setting_set_to_true", &test_checkout_index__honor_coresymlinks_setting_set_to_true},
	{"honor_the_gitattributes_directives", &test_checkout_index__honor_the_gitattributes_directives},
	{"honor_the_specified_pathspecs", &test_checkout_index__honor_the_specified_pathspecs},
	{"options_dir_modes", &test_checkout_index__options_dir_modes},
	{"options_disable_filters", &test_checkout_index__options_disable_filters},
	{"options_open_flags", &test_checkout_index__options_open_flags},
	{"options_override_file_modes", &test_checkout_index__options_override_file_modes},
	{"wont_notify_of_expected_line_ending_changes", &test_checkout_index__wont_notify_of_expected_line_ending_changes}
};
static const struct clar_func _clar_cb_checkout_tree[] = {
    {"calls_progress_callback", &test_checkout_tree__calls_progress_callback},
	{"can_checkout_a_subdirectory_from_a_commit", &test_checkout_tree__can_checkout_a_subdirectory_from_a_commit},
	{"can_checkout_a_subdirectory_from_a_subtree", &test_checkout_tree__can_checkout_a_subdirectory_from_a_subtree},
	{"cannot_checkout_a_non_treeish", &test_checkout_tree__cannot_checkout_a_non_treeish}
};
static const struct clar_func _clar_cb_checkout_typechange[] = {
    {"checkout_typechanges", &test_checkout_typechange__checkout_typechanges}
};
static const struct clar_func _clar_cb_clone_network[] = {
    {"can_checkout_a_cloned_repo", &test_clone_network__can_checkout_a_cloned_repo},
	{"can_prevent_the_checkout_of_a_standard_repo", &test_clone_network__can_prevent_the_checkout_of_a_standard_repo},
	{"cope_with_already_existing_directory", &test_clone_network__cope_with_already_existing_directory},
	{"empty_repository", &test_clone_network__empty_repository},
	{"network_bare", &test_clone_network__network_bare},
	{"network_full", &test_clone_network__network_full}
};
static const struct clar_func _clar_cb_clone_nonetwork[] = {
    {"bad_url", &test_clone_nonetwork__bad_url},
	{"fail_when_the_target_is_a_file", &test_clone_nonetwork__fail_when_the_target_is_a_file},
	{"fail_with_already_existing_but_non_empty_directory", &test_clone_nonetwork__fail_with_already_existing_but_non_empty_directory},
	{"local", &test_clone_nonetwork__local},
	{"local_bare", &test_clone_nonetwork__local_bare}
};
static const struct clar_func _clar_cb_commit_commit[] = {
    {"create_unexisting_update_ref", &test_commit_commit__create_unexisting_update_ref}
};
static const struct clar_func _clar_cb_commit_parent[] = {
    {"can_retrieve_nth_generation_parent", &test_commit_parent__can_retrieve_nth_generation_parent}
};
static const struct clar_func _clar_cb_commit_parse[] = {
    {"details0", &test_commit_parse__details0},
	{"entire_commit", &test_commit_parse__entire_commit},
	{"header", &test_commit_parse__header},
	{"signature", &test_commit_parse__signature}
};
static const struct clar_func _clar_cb_commit_signature[] = {
    {"angle_brackets_in_email_are_not_supported", &test_commit_signature__angle_brackets_in_email_are_not_supported},
	{"angle_brackets_in_names_are_not_supported", &test_commit_signature__angle_brackets_in_names_are_not_supported},
	{"create_empties", &test_commit_signature__create_empties},
	{"create_one_char", &test_commit_signature__create_one_char},
	{"create_two_char", &test_commit_signature__create_two_char},
	{"create_zero_char", &test_commit_signature__create_zero_char},
	{"leading_and_trailing_spaces_are_trimmed", &test_commit_signature__leading_and_trailing_spaces_are_trimmed}
};
static const struct clar_func _clar_cb_commit_write[] = {
    {"from_memory", &test_commit_write__from_memory},
	{"root", &test_commit_write__root}
};
static const struct clar_func _clar_cb_config_add[] = {
    {"to_existing_section", &test_config_add__to_existing_section},
	{"to_new_section", &test_config_add__to_new_section}
};
static const struct clar_func _clar_cb_config_configlevel[] = {
    {"adding_the_same_level_twice_returns_EEXISTS", &test_config_configlevel__adding_the_same_level_twice_returns_EEXISTS},
	{"can_read_from_a_single_level_focused_file_after_parent_config_has_been_freed", &test_config_configlevel__can_read_from_a_single_level_focused_file_after_parent_config_has_been_freed},
	{"can_replace_a_config_file_at_an_existing_level", &test_config_configlevel__can_replace_a_config_file_at_an_existing_level},
	{"fetching_a_level_from_an_empty_compound_config_returns_ENOTFOUND", &test_config_configlevel__fetching_a_level_from_an_empty_compound_config_returns_ENOTFOUND}
};
static const struct clar_func _clar_cb_config_multivar[] = {
    {"add", &test_config_multivar__add},
	{"foreach", &test_config_multivar__foreach},
	{"get", &test_config_multivar__get},
	{"replace", &test_config_multivar__replace},
	{"replace_multiple", &test_config_multivar__replace_multiple}
};
static const struct clar_func _clar_cb_config_new[] = {
    {"write_new_config", &test_config_new__write_new_config}
};
static const struct clar_func _clar_cb_config_read[] = {
    {"blank_lines", &test_config_read__blank_lines},
	{"can_load_and_parse_an_empty_config_file", &test_config_read__can_load_and_parse_an_empty_config_file},
	{"cannot_load_a_non_existing_config_file", &test_config_read__cannot_load_a_non_existing_config_file},
	{"case_sensitive", &test_config_read__case_sensitive},
	{"empty_files", &test_config_read__empty_files},
	{"escaping_quotes", &test_config_read__escaping_quotes},
	{"fallback_from_local_to_global_and_from_global_to_system", &test_config_read__fallback_from_local_to_global_and_from_global_to_system},
	{"foreach", &test_config_read__foreach},
	{"foreach_match", &test_config_read__foreach_match},
	{"header_in_last_line", &test_config_read__header_in_last_line},
	{"invalid_ext_headers", &test_config_read__invalid_ext_headers},
	{"local_config_overrides_global_config_overrides_system_config", &test_config_read__local_config_overrides_global_config_overrides_system_config},
	{"lone_variable", &test_config_read__lone_variable},
	{"multiline_value", &test_config_read__multiline_value},
	{"number_suffixes", &test_config_read__number_suffixes},
	{"prefixes", &test_config_read__prefixes},
	{"read_git_config_entry", &test_config_read__read_git_config_entry},
	{"simple_read", &test_config_read__simple_read},
	{"simple_read_from_specific_level", &test_config_read__simple_read_from_specific_level},
	{"subsection_header", &test_config_read__subsection_header},
	{"whitespace_not_required_around_assignment", &test_config_read__whitespace_not_required_around_assignment}
};
static const struct clar_func _clar_cb_config_refresh[] = {
    {"delete_value", &test_config_refresh__delete_value},
	{"update_value", &test_config_refresh__update_value}
};
static const struct clar_func _clar_cb_config_stress[] = {
    {"comments", &test_config_stress__comments},
	{"dont_break_on_invalid_input", &test_config_stress__dont_break_on_invalid_input},
	{"escape_subsection_names", &test_config_stress__escape_subsection_names}
};
static const struct clar_func _clar_cb_config_write[] = {
    {"add_value_at_file_with_no_clrf_at_the_end", &test_config_write__add_value_at_file_with_no_clrf_at_the_end},
	{"add_value_at_specific_level", &test_config_write__add_value_at_specific_level},
	{"delete_inexistent", &test_config_write__delete_inexistent},
	{"delete_value", &test_config_write__delete_value},
	{"delete_value_at_specific_level", &test_config_write__delete_value_at_specific_level},
	{"escape_value", &test_config_write__escape_value},
	{"replace_value", &test_config_write__replace_value},
	{"value_containing_quotes", &test_config_write__value_containing_quotes},
	{"write_subsection", &test_config_write__write_subsection}
};
static const struct clar_func _clar_cb_core_buffer[] = {
    {"0", &test_core_buffer__0},
	{"1", &test_core_buffer__1},
	{"10", &test_core_buffer__10},
	{"11", &test_core_buffer__11},
	{"2", &test_core_buffer__2},
	{"3", &test_core_buffer__3},
	{"4", &test_core_buffer__4},
	{"5", &test_core_buffer__5},
	{"6", &test_core_buffer__6},
	{"7", &test_core_buffer__7},
	{"8", &test_core_buffer__8},
	{"9", &test_core_buffer__9},
	{"base64", &test_core_buffer__base64},
	{"puts_escaped", &test_core_buffer__puts_escaped},
	{"rfind_variants", &test_core_buffer__rfind_variants},
	{"unescape", &test_core_buffer__unescape}
};
static const struct clar_func _clar_cb_core_copy[] = {
    {"file", &test_core_copy__file},
	{"file_in_dir", &test_core_copy__file_in_dir},
	{"tree", &test_core_copy__tree}
};
static const struct clar_func _clar_cb_core_dirent[] = {
    {"dont_traverse_dot", &test_core_dirent__dont_traverse_dot},
	{"dont_traverse_empty_folders", &test_core_dirent__dont_traverse_empty_folders},
	{"length_limits", &test_core_dirent__length_limits},
	{"traverse_slash_terminated_folder", &test_core_dirent__traverse_slash_terminated_folder},
	{"traverse_subfolder", &test_core_dirent__traverse_subfolder},
	{"traverse_weird_filenames", &test_core_dirent__traverse_weird_filenames}
};
static const struct clar_func _clar_cb_core_env[] = {
    {"0", &test_core_env__0},
	{"1", &test_core_env__1}
};
static const struct clar_func _clar_cb_core_errors[] = {
    {"new_school", &test_core_errors__new_school},
	{"public_api", &test_core_errors__public_api}
};
static const struct clar_func _clar_cb_core_filebuf[] = {
    {"0", &test_core_filebuf__0},
	{"1", &test_core_filebuf__1},
	{"2", &test_core_filebuf__2},
	{"4", &test_core_filebuf__4},
	{"5", &test_core_filebuf__5}
};
static const struct clar_func _clar_cb_core_hex[] = {
    {"fromhex", &test_core_hex__fromhex}
};
static const struct clar_func _clar_cb_core_mkdir[] = {
    {"basic", &test_core_mkdir__basic},
	{"chmods", &test_core_mkdir__chmods},
	{"with_base", &test_core_mkdir__with_base}
};
static const struct clar_func _clar_cb_core_oid[] = {
    {"streq", &test_core_oid__streq}
};
static const struct clar_func _clar_cb_core_path[] = {
    {"00_dirname", &test_core_path__00_dirname},
	{"01_basename", &test_core_path__01_basename},
	{"02_topdir", &test_core_path__02_topdir},
	{"05_joins", &test_core_path__05_joins},
	{"06_long_joins", &test_core_path__06_long_joins},
	{"07_path_to_dir", &test_core_path__07_path_to_dir},
	{"08_self_join", &test_core_path__08_self_join},
	{"09_percent_decode", &test_core_path__09_percent_decode},
	{"10_fromurl", &test_core_path__10_fromurl},
	{"11_walkup", &test_core_path__11_walkup},
	{"12_offset_to_path_root", &test_core_path__12_offset_to_path_root},
	{"13_cannot_prettify_a_non_existing_file", &test_core_path__13_cannot_prettify_a_non_existing_file},
	{"14_apply_relative", &test_core_path__14_apply_relative}
};
static const struct clar_func _clar_cb_core_pool[] = {
    {"0", &test_core_pool__0},
	{"1", &test_core_pool__1},
	{"2", &test_core_pool__2}
};
static const struct clar_func _clar_cb_core_rmdir[] = {
    {"can_remove_empty_parents", &test_core_rmdir__can_remove_empty_parents},
	{"can_skip_non_empty_dir", &test_core_rmdir__can_skip_non_empty_dir},
	{"delete_recursive", &test_core_rmdir__delete_recursive},
	{"fail_to_delete_non_empty_dir", &test_core_rmdir__fail_to_delete_non_empty_dir}
};
static const struct clar_func _clar_cb_core_stat[] = {
    {"0", &test_core_stat__0}
};
static const struct clar_func _clar_cb_core_string[] = {
    {"0", &test_core_string__0},
	{"1", &test_core_string__1}
};
static const struct clar_func _clar_cb_core_strmap[] = {
    {"0", &test_core_strmap__0},
	{"1", &test_core_strmap__1},
	{"2", &test_core_strmap__2},
	{"3", &test_core_strmap__3}
};
static const struct clar_func _clar_cb_core_strtol[] = {
    {"int32", &test_core_strtol__int32},
	{"int64", &test_core_strtol__int64}
};
static const struct clar_func _clar_cb_core_vector[] = {
    {"0", &test_core_vector__0},
	{"1", &test_core_vector__1},
	{"2", &test_core_vector__2},
	{"3", &test_core_vector__3},
	{"4", &test_core_vector__4},
	{"5", &test_core_vector__5},
	{"remove_matching", &test_core_vector__remove_matching}
};
static const struct clar_func _clar_cb_date_date[] = {
    {"overflow", &test_date_date__overflow}
};
static const struct clar_func _clar_cb_diff_blob[] = {
    {"can_compare_a_binary_blob_and_a_text_blob", &test_diff_blob__can_compare_a_binary_blob_and_a_text_blob},
	{"can_compare_against_null_blobs", &test_diff_blob__can_compare_against_null_blobs},
	{"can_compare_identical_blobs", &test_diff_blob__can_compare_identical_blobs},
	{"can_compare_text_blobs", &test_diff_blob__can_compare_text_blobs},
	{"can_compare_two_binary_blobs", &test_diff_blob__can_compare_two_binary_blobs},
	{"comparing_two_text_blobs_honors_interhunkcontext", &test_diff_blob__comparing_two_text_blobs_honors_interhunkcontext}
};
static const struct clar_func _clar_cb_diff_diffiter[] = {
    {"create", &test_diff_diffiter__create},
	{"iterate_all", &test_diff_diffiter__iterate_all},
	{"iterate_and_generate_patch_text", &test_diff_diffiter__iterate_and_generate_patch_text},
	{"iterate_files", &test_diff_diffiter__iterate_files},
	{"iterate_files_2", &test_diff_diffiter__iterate_files_2},
	{"iterate_files_and_hunks", &test_diff_diffiter__iterate_files_and_hunks},
	{"iterate_randomly_while_saving_state", &test_diff_diffiter__iterate_randomly_while_saving_state},
	{"max_size_threshold", &test_diff_diffiter__max_size_threshold}
};
static const struct clar_func _clar_cb_diff_index[] = {
    {"0", &test_diff_index__0},
	{"1", &test_diff_index__1}
};
static const struct clar_func _clar_cb_diff_iterator[] = {
    {"index_0", &test_diff_iterator__index_0},
	{"index_1", &test_diff_iterator__index_1},
	{"index_range", &test_diff_iterator__index_range},
	{"index_range_empty_0", &test_diff_iterator__index_range_empty_0},
	{"index_range_empty_1", &test_diff_iterator__index_range_empty_1},
	{"index_range_empty_2", &test_diff_iterator__index_range_empty_2},
	{"tree_0", &test_diff_iterator__tree_0},
	{"tree_1", &test_diff_iterator__tree_1},
	{"tree_2", &test_diff_iterator__tree_2},
	{"tree_3", &test_diff_iterator__tree_3},
	{"tree_4", &test_diff_iterator__tree_4},
	{"tree_4_ranged", &test_diff_iterator__tree_4_ranged},
	{"tree_range_empty_0", &test_diff_iterator__tree_range_empty_0},
	{"tree_range_empty_1", &test_diff_iterator__tree_range_empty_1},
	{"tree_range_empty_2", &test_diff_iterator__tree_range_empty_2},
	{"tree_ranged_0", &test_diff_iterator__tree_ranged_0},
	{"tree_ranged_1", &test_diff_iterator__tree_ranged_1},
	{"tree_special_functions", &test_diff_iterator__tree_special_functions},
	{"workdir_0", &test_diff_iterator__workdir_0},
	{"workdir_1", &test_diff_iterator__workdir_1},
	{"workdir_1_ranged_0", &test_diff_iterator__workdir_1_ranged_0},
	{"workdir_1_ranged_1", &test_diff_iterator__workdir_1_ranged_1},
	{"workdir_1_ranged_3", &test_diff_iterator__workdir_1_ranged_3},
	{"workdir_1_ranged_4", &test_diff_iterator__workdir_1_ranged_4},
	{"workdir_1_ranged_5", &test_diff_iterator__workdir_1_ranged_5},
	{"workdir_1_ranged_empty_0", &test_diff_iterator__workdir_1_ranged_empty_0},
	{"workdir_1_ranged_empty_1", &test_diff_iterator__workdir_1_ranged_empty_1},
	{"workdir_1_ranged_empty_2", &test_diff_iterator__workdir_1_ranged_empty_2}
};
static const struct clar_func _clar_cb_diff_patch[] = {
    {"can_properly_display_the_removal_of_a_file", &test_diff_patch__can_properly_display_the_removal_of_a_file},
	{"to_string", &test_diff_patch__to_string}
};
static const struct clar_func _clar_cb_diff_rename[] = {
    {"match_oid", &test_diff_rename__match_oid}
};
static const struct clar_func _clar_cb_diff_tree[] = {
    {"0", &test_diff_tree__0},
	{"bare", &test_diff_tree__bare},
	{"larger_hunks", &test_diff_tree__larger_hunks},
	{"merge", &test_diff_tree__merge},
	{"options", &test_diff_tree__options}
};
static const struct clar_func _clar_cb_diff_workdir[] = {
    {"cannot_diff_against_a_bare_repository", &test_diff_workdir__cannot_diff_against_a_bare_repository},
	{"eof_newline_changes", &test_diff_workdir__eof_newline_changes},
	{"filemode_changes", &test_diff_workdir__filemode_changes},
	{"filemode_changes_with_filemode_false", &test_diff_workdir__filemode_changes_with_filemode_false},
	{"head_index_and_workdir_all_differ", &test_diff_workdir__head_index_and_workdir_all_differ},
	{"larger_hunks", &test_diff_workdir__larger_hunks},
	{"submodules", &test_diff_workdir__submodules},
	{"to_index", &test_diff_workdir__to_index},
	{"to_index_with_pathspec", &test_diff_workdir__to_index_with_pathspec},
	{"to_tree", &test_diff_workdir__to_tree}
};
static const struct clar_func _clar_cb_fetchhead_network[] = {
    {"explicit_spec", &test_fetchhead_network__explicit_spec},
	{"no_merges", &test_fetchhead_network__no_merges},
	{"wildcard_spec", &test_fetchhead_network__wildcard_spec}
};
static const struct clar_func _clar_cb_fetchhead_nonetwork[] = {
    {"write", &test_fetchhead_nonetwork__write}
};
static const struct clar_func _clar_cb_index_conflicts[] = {
    {"add", &test_index_conflicts__add},
	{"add_fixes_incorrect_stage", &test_index_conflicts__add_fixes_incorrect_stage},
	{"get", &test_index_conflicts__get},
	{"moved_to_reuc", &test_index_conflicts__moved_to_reuc},
	{"partial", &test_index_conflicts__partial},
	{"remove", &test_index_conflicts__remove},
	{"remove_all_conflicts", &test_index_conflicts__remove_all_conflicts}
};
static const struct clar_func _clar_cb_index_filemodes[] = {
    {"read", &test_index_filemodes__read},
	{"trusted", &test_index_filemodes__trusted},
	{"untrusted", &test_index_filemodes__untrusted}
};
static const struct clar_func _clar_cb_index_inmemory[] = {
    {"can_create_an_inmemory_index", &test_index_inmemory__can_create_an_inmemory_index},
	{"cannot_add_from_workdir_to_an_inmemory_index", &test_index_inmemory__cannot_add_from_workdir_to_an_inmemory_index}
};
static const struct clar_func _clar_cb_index_read_tree[] = {
    {"read_write_involution", &test_index_read_tree__read_write_involution}
};
static const struct clar_func _clar_cb_index_rename[] = {
    {"single_file", &test_index_rename__single_file}
};
static const struct clar_func _clar_cb_index_reuc[] = {
    {"ignore_case", &test_index_reuc__ignore_case},
	{"read_byindex", &test_index_reuc__read_byindex},
	{"read_bypath", &test_index_reuc__read_bypath},
	{"remove", &test_index_reuc__remove},
	{"updates_existing", &test_index_reuc__updates_existing},
	{"write", &test_index_reuc__write}
};
static const struct clar_func _clar_cb_index_stage[] = {
    {"add_always_adds_stage_0", &test_index_stage__add_always_adds_stage_0},
	{"find_gets_first_stage", &test_index_stage__find_gets_first_stage}
};
static const struct clar_func _clar_cb_index_tests[] = {
    {"add", &test_index_tests__add},
	{"add_from_workdir_to_a_bare_repository_returns_EBAREPO", &test_index_tests__add_from_workdir_to_a_bare_repository_returns_EBAREPO},
	{"default_test_index", &test_index_tests__default_test_index},
	{"empty_index", &test_index_tests__empty_index},
	{"find_in_empty", &test_index_tests__find_in_empty},
	{"find_in_existing", &test_index_tests__find_in_existing},
	{"gitgit_index", &test_index_tests__gitgit_index},
	{"sort0", &test_index_tests__sort0},
	{"sort1", &test_index_tests__sort1},
	{"write", &test_index_tests__write},
	{"write_invalid_filename", &test_index_tests__write_invalid_filename}
};
static const struct clar_func _clar_cb_network_createremotethenload[] = {
    {"parsing", &test_network_createremotethenload__parsing}
};
static const struct clar_func _clar_cb_network_fetch[] = {
    {"default_git", &test_network_fetch__default_git},
	{"default_http", &test_network_fetch__default_http},
	{"no_tags_git", &test_network_fetch__no_tags_git},
	{"no_tags_http", &test_network_fetch__no_tags_http}
};
static const struct clar_func _clar_cb_network_fetchlocal[] = {
    {"complete", &test_network_fetchlocal__complete},
	{"partial", &test_network_fetchlocal__partial}
};
static const struct clar_func _clar_cb_network_refspecs[] = {
    {"parsing", &test_network_refspecs__parsing}
};
static const struct clar_func _clar_cb_network_remotelocal[] = {
    {"connected", &test_network_remotelocal__connected},
	{"nested_tags_are_completely_peeled", &test_network_remotelocal__nested_tags_are_completely_peeled},
	{"retrieve_advertised_references", &test_network_remotelocal__retrieve_advertised_references},
	{"retrieve_advertised_references_from_spaced_repository", &test_network_remotelocal__retrieve_advertised_references_from_spaced_repository}
};
static const struct clar_func _clar_cb_network_remoterename[] = {
    {"cannot_overwrite_an_existing_remote", &test_network_remoterename__cannot_overwrite_an_existing_remote},
	{"new_name_can_contain_dots", &test_network_remoterename__new_name_can_contain_dots},
	{"new_name_must_conform_to_reference_naming_conventions", &test_network_remoterename__new_name_must_conform_to_reference_naming_conventions},
	{"renamed_name_is_persisted", &test_network_remoterename__renamed_name_is_persisted},
	{"renaming_a_remote_moves_related_configuration_section", &test_network_remoterename__renaming_a_remote_moves_related_configuration_section},
	{"renaming_a_remote_moves_the_underlying_reference", &test_network_remoterename__renaming_a_remote_moves_the_underlying_reference},
	{"renaming_a_remote_notifies_of_non_default_fetchrefspec", &test_network_remoterename__renaming_a_remote_notifies_of_non_default_fetchrefspec},
	{"renaming_a_remote_updates_branch_related_configuration_entries", &test_network_remoterename__renaming_a_remote_updates_branch_related_configuration_entries},
	{"renaming_a_remote_updates_default_fetchrefspec", &test_network_remoterename__renaming_a_remote_updates_default_fetchrefspec},
	{"renaming_a_remote_without_a_fetchrefspec_doesnt_create_one", &test_network_remoterename__renaming_a_remote_without_a_fetchrefspec_doesnt_create_one},
	{"renaming_an_inmemory_nameless_remote_notifies_the_inability_to_update_the_fetch_refspec", &test_network_remoterename__renaming_an_inmemory_nameless_remote_notifies_the_inability_to_update_the_fetch_refspec},
	{"renaming_an_inmemory_remote_persists_it", &test_network_remoterename__renaming_an_inmemory_remote_persists_it}
};
static const struct clar_func _clar_cb_network_remotes[] = {
    {"add", &test_network_remotes__add},
	{"cannot_add_a_nameless_remote", &test_network_remotes__cannot_add_a_nameless_remote},
	{"cannot_load_with_an_empty_url", &test_network_remotes__cannot_load_with_an_empty_url},
	{"cannot_save_a_nameless_remote", &test_network_remotes__cannot_save_a_nameless_remote},
	{"fnmatch", &test_network_remotes__fnmatch},
	{"list", &test_network_remotes__list},
	{"loading_a_missing_remote_returns_ENOTFOUND", &test_network_remotes__loading_a_missing_remote_returns_ENOTFOUND},
	{"missing_refspecs", &test_network_remotes__missing_refspecs},
	{"parsing", &test_network_remotes__parsing},
	{"parsing_local_path_fails_if_path_not_found", &test_network_remotes__parsing_local_path_fails_if_path_not_found},
	{"parsing_ssh_remote", &test_network_remotes__parsing_ssh_remote},
	{"pushurl", &test_network_remotes__pushurl},
	{"refspec_parsing", &test_network_remotes__refspec_parsing},
	{"save", &test_network_remotes__save},
	{"set_fetchspec", &test_network_remotes__set_fetchspec},
	{"set_pushspec", &test_network_remotes__set_pushspec},
	{"supported_transport_methods_are_supported", &test_network_remotes__supported_transport_methods_are_supported},
	{"tagopt", &test_network_remotes__tagopt},
	{"transform", &test_network_remotes__transform},
	{"transform_r", &test_network_remotes__transform_r},
	{"unsupported_transport_methods_are_unsupported", &test_network_remotes__unsupported_transport_methods_are_unsupported}
};
static const struct clar_func _clar_cb_notes_notes[] = {
    {"can_cancel_foreach", &test_notes_notes__can_cancel_foreach},
	{"can_insert_a_note_in_an_existing_fanout", &test_notes_notes__can_insert_a_note_in_an_existing_fanout},
	{"can_insert_a_note_with_a_custom_namespace", &test_notes_notes__can_insert_a_note_with_a_custom_namespace},
	{"can_read_a_note_in_an_existing_fanout", &test_notes_notes__can_read_a_note_in_an_existing_fanout},
	{"can_remove_a_note_in_an_existing_fanout", &test_notes_notes__can_remove_a_note_in_an_existing_fanout},
	{"can_retrieve_a_list_of_notes_for_a_given_namespace", &test_notes_notes__can_retrieve_a_list_of_notes_for_a_given_namespace},
	{"creating_a_note_on_a_target_which_already_has_one_returns_EEXISTS", &test_notes_notes__creating_a_note_on_a_target_which_already_has_one_returns_EEXISTS},
	{"inserting_a_note_without_passing_a_namespace_uses_the_default_namespace", &test_notes_notes__inserting_a_note_without_passing_a_namespace_uses_the_default_namespace},
	{"removing_a_note_which_doesnt_exists_returns_ENOTFOUND", &test_notes_notes__removing_a_note_which_doesnt_exists_returns_ENOTFOUND},
	{"retrieving_a_list_of_notes_for_an_unknown_namespace_returns_ENOTFOUND", &test_notes_notes__retrieving_a_list_of_notes_for_an_unknown_namespace_returns_ENOTFOUND}
};
static const struct clar_func _clar_cb_notes_notesref[] = {
    {"config_corenotesref", &test_notes_notesref__config_corenotesref}
};
static const struct clar_func _clar_cb_object_blob_filter[] = {
    {"stats", &test_object_blob_filter__stats},
	{"to_odb", &test_object_blob_filter__to_odb},
	{"unfiltered", &test_object_blob_filter__unfiltered}
};
static const struct clar_func _clar_cb_object_blob_fromchunks[] = {
    {"can_create_a_blob_from_a_in_memory_chunk_provider", &test_object_blob_fromchunks__can_create_a_blob_from_a_in_memory_chunk_provider},
	{"creating_a_blob_from_chunks_honors_the_attributes_directives", &test_object_blob_fromchunks__creating_a_blob_from_chunks_honors_the_attributes_directives}
};
static const struct clar_func _clar_cb_object_blob_write[] = {
    {"can_create_a_blob_in_a_bare_repo_from_a_absolute_filepath", &test_object_blob_write__can_create_a_blob_in_a_bare_repo_from_a_absolute_filepath},
	{"can_create_a_blob_in_a_standard_repo_from_a_absolute_filepath_pointing_outside_of_the_working_directory", &test_object_blob_write__can_create_a_blob_in_a_standard_repo_from_a_absolute_filepath_pointing_outside_of_the_working_directory},
	{"can_create_a_blob_in_a_standard_repo_from_a_file_located_in_the_working_directory", &test_object_blob_write__can_create_a_blob_in_a_standard_repo_from_a_file_located_in_the_working_directory}
};
static const struct clar_func _clar_cb_object_commit_commitstagedfile[] = {
    {"generate_predictable_object_ids", &test_object_commit_commitstagedfile__generate_predictable_object_ids}
};
static const struct clar_func _clar_cb_object_lookup[] = {
    {"lookup_nonexisting_returns_enotfound", &test_object_lookup__lookup_nonexisting_returns_enotfound},
	{"lookup_wrong_type_by_abbreviated_id_returns_enotfound", &test_object_lookup__lookup_wrong_type_by_abbreviated_id_returns_enotfound},
	{"lookup_wrong_type_eventually_returns_enotfound", &test_object_lookup__lookup_wrong_type_eventually_returns_enotfound},
	{"lookup_wrong_type_returns_enotfound", &test_object_lookup__lookup_wrong_type_returns_enotfound}
};
static const struct clar_func _clar_cb_object_message[] = {
    {"consecutive_blank_lines_at_the_beginning_should_be_removed", &test_object_message__consecutive_blank_lines_at_the_beginning_should_be_removed},
	{"consecutive_blank_lines_at_the_end_should_be_removed", &test_object_message__consecutive_blank_lines_at_the_end_should_be_removed},
	{"consecutive_blank_lines_should_be_unified", &test_object_message__consecutive_blank_lines_should_be_unified},
	{"consecutive_text_lines_should_be_unchanged", &test_object_message__consecutive_text_lines_should_be_unchanged},
	{"keep_comments", &test_object_message__keep_comments},
	{"lines_with_intermediate_spaces_should_be_unchanged", &test_object_message__lines_with_intermediate_spaces_should_be_unchanged},
	{"lines_with_spaces_at_the_beginning_should_be_unchanged", &test_object_message__lines_with_spaces_at_the_beginning_should_be_unchanged},
	{"long_lines_without_spaces_should_be_unchanged", &test_object_message__long_lines_without_spaces_should_be_unchanged},
	{"message_prettify", &test_object_message__message_prettify},
	{"only_consecutive_blank_lines_should_be_completely_removed", &test_object_message__only_consecutive_blank_lines_should_be_completely_removed},
	{"spaces_with_newline_at_end_should_be_replaced_with_empty_string", &test_object_message__spaces_with_newline_at_end_should_be_replaced_with_empty_string},
	{"spaces_without_newline_at_end_should_be_replaced_with_empty_string", &test_object_message__spaces_without_newline_at_end_should_be_replaced_with_empty_string},
	{"strip_comments", &test_object_message__strip_comments},
	{"text_plus_spaces_ending_with_newline_should_be_cleaned_and_newline_must_remain", &test_object_message__text_plus_spaces_ending_with_newline_should_be_cleaned_and_newline_must_remain},
	{"text_plus_spaces_without_newline_should_not_show_spaces_and_end_with_newline", &test_object_message__text_plus_spaces_without_newline_should_not_show_spaces_and_end_with_newline},
	{"text_without_newline_at_end_should_end_with_newline", &test_object_message__text_without_newline_at_end_should_end_with_newline}
};
static const struct clar_func _clar_cb_object_peel[] = {
    {"can_peel_a_commit", &test_object_peel__can_peel_a_commit},
	{"can_peel_a_tag", &test_object_peel__can_peel_a_tag},
	{"cannot_peel_a_blob", &test_object_peel__cannot_peel_a_blob},
	{"cannot_peel_a_tree", &test_object_peel__cannot_peel_a_tree},
	{"peeling_an_object_into_its_own_type_returns_another_instance_of_it", &test_object_peel__peeling_an_object_into_its_own_type_returns_another_instance_of_it},
	{"target_any_object_for_type_change", &test_object_peel__target_any_object_for_type_change}
};
static const struct clar_func _clar_cb_object_raw_chars[] = {
    {"build_valid_oid_from_raw_bytes", &test_object_raw_chars__build_valid_oid_from_raw_bytes},
	{"find_invalid_chars_in_oid", &test_object_raw_chars__find_invalid_chars_in_oid}
};
static const struct clar_func _clar_cb_object_raw_compare[] = {
    {"compare_allocfmt_oids", &test_object_raw_compare__compare_allocfmt_oids},
	{"compare_fmt_oids", &test_object_raw_compare__compare_fmt_oids},
	{"compare_pathfmt_oids", &test_object_raw_compare__compare_pathfmt_oids},
	{"succeed_on_copy_oid", &test_object_raw_compare__succeed_on_copy_oid},
	{"succeed_on_oid_comparison_equal", &test_object_raw_compare__succeed_on_oid_comparison_equal},
	{"succeed_on_oid_comparison_greater", &test_object_raw_compare__succeed_on_oid_comparison_greater},
	{"succeed_on_oid_comparison_lesser", &test_object_raw_compare__succeed_on_oid_comparison_lesser}
};
static const struct clar_func _clar_cb_object_raw_convert[] = {
    {"succeed_on_oid_to_string_conversion", &test_object_raw_convert__succeed_on_oid_to_string_conversion},
	{"succeed_on_oid_to_string_conversion_big", &test_object_raw_convert__succeed_on_oid_to_string_conversion_big}
};
static const struct clar_func _clar_cb_object_raw_fromstr[] = {
    {"fail_on_invalid_oid_string", &test_object_raw_fromstr__fail_on_invalid_oid_string},
	{"succeed_on_valid_oid_string", &test_object_raw_fromstr__succeed_on_valid_oid_string}
};
static const struct clar_func _clar_cb_object_raw_hash[] = {
    {"hash_buffer_in_single_call", &test_object_raw_hash__hash_buffer_in_single_call},
	{"hash_by_blocks", &test_object_raw_hash__hash_by_blocks},
	{"hash_commit_object", &test_object_raw_hash__hash_commit_object},
	{"hash_junk_data", &test_object_raw_hash__hash_junk_data},
	{"hash_multi_byte_object", &test_object_raw_hash__hash_multi_byte_object},
	{"hash_one_byte_object", &test_object_raw_hash__hash_one_byte_object},
	{"hash_tag_object", &test_object_raw_hash__hash_tag_object},
	{"hash_tree_object", &test_object_raw_hash__hash_tree_object},
	{"hash_two_byte_object", &test_object_raw_hash__hash_two_byte_object},
	{"hash_vector", &test_object_raw_hash__hash_vector},
	{"hash_zero_length_object", &test_object_raw_hash__hash_zero_length_object}
};
static const struct clar_func _clar_cb_object_raw_short[] = {
    {"oid_shortener_no_duplicates", &test_object_raw_short__oid_shortener_no_duplicates},
	{"oid_shortener_stresstest_git_oid_shorten", &test_object_raw_short__oid_shortener_stresstest_git_oid_shorten}
};
static const struct clar_func _clar_cb_object_raw_size[] = {
    {"validate_oid_size", &test_object_raw_size__validate_oid_size}
};
static const struct clar_func _clar_cb_object_raw_type2string[] = {
    {"check_type_is_loose", &test_object_raw_type2string__check_type_is_loose},
	{"convert_string_to_type", &test_object_raw_type2string__convert_string_to_type},
	{"convert_type_to_string", &test_object_raw_type2string__convert_type_to_string}
};
static const struct clar_func _clar_cb_object_raw_write[] = {
    {"loose_object", &test_object_raw_write__loose_object},
	{"loose_tag", &test_object_raw_write__loose_tag},
	{"loose_tree", &test_object_raw_write__loose_tree},
	{"one_byte", &test_object_raw_write__one_byte},
	{"several_bytes", &test_object_raw_write__several_bytes},
	{"two_byte", &test_object_raw_write__two_byte},
	{"zero_length", &test_object_raw_write__zero_length}
};
static const struct clar_func _clar_cb_object_tag_list[] = {
    {"list_all", &test_object_tag_list__list_all},
	{"list_by_pattern", &test_object_tag_list__list_by_pattern}
};
static const struct clar_func _clar_cb_object_tag_peel[] = {
    {"can_peel_several_nested_tags_to_a_commit", &test_object_tag_peel__can_peel_several_nested_tags_to_a_commit},
	{"can_peel_to_a_commit", &test_object_tag_peel__can_peel_to_a_commit},
	{"can_peel_to_a_non_commit", &test_object_tag_peel__can_peel_to_a_non_commit}
};
static const struct clar_func _clar_cb_object_tag_read[] = {
    {"parse", &test_object_tag_read__parse},
	{"parse_without_message", &test_object_tag_read__parse_without_message},
	{"parse_without_tagger", &test_object_tag_read__parse_without_tagger}
};
static const struct clar_func _clar_cb_object_tag_write[] = {
    {"basic", &test_object_tag_write__basic},
	{"delete", &test_object_tag_write__delete},
	{"lightweight", &test_object_tag_write__lightweight},
	{"lightweight_over_existing", &test_object_tag_write__lightweight_over_existing},
	{"overwrite", &test_object_tag_write__overwrite},
	{"replace", &test_object_tag_write__replace}
};
static const struct clar_func _clar_cb_object_tree_attributes[] = {
    {"ensure_correctness_of_attributes_on_insertion", &test_object_tree_attributes__ensure_correctness_of_attributes_on_insertion},
	{"group_writable_tree_entries_created_with_an_antique_git_version_can_still_be_accessed", &test_object_tree_attributes__group_writable_tree_entries_created_with_an_antique_git_version_can_still_be_accessed},
	{"normalize_attributes_when_creating_a_tree_from_an_existing_one", &test_object_tree_attributes__normalize_attributes_when_creating_a_tree_from_an_existing_one},
	{"normalize_attributes_when_inserting_in_a_new_tree", &test_object_tree_attributes__normalize_attributes_when_inserting_in_a_new_tree}
};
static const struct clar_func _clar_cb_object_tree_duplicateentries[] = {
    {"cannot_create_a_duplicate_entry_building_a_tree_from_a_index_with_conflicts", &test_object_tree_duplicateentries__cannot_create_a_duplicate_entry_building_a_tree_from_a_index_with_conflicts},
	{"cannot_create_a_duplicate_entry_through_the_treebuilder", &test_object_tree_duplicateentries__cannot_create_a_duplicate_entry_through_the_treebuilder}
};
static const struct clar_func _clar_cb_object_tree_frompath[] = {
    {"fail_when_processing_an_invalid_path", &test_object_tree_frompath__fail_when_processing_an_invalid_path},
	{"retrieve_tree_from_path_to_treeentry", &test_object_tree_frompath__retrieve_tree_from_path_to_treeentry}
};
static const struct clar_func _clar_cb_object_tree_read[] = {
    {"loaded", &test_object_tree_read__loaded},
	{"two", &test_object_tree_read__two}
};
static const struct clar_func _clar_cb_object_tree_walk[] = {
    {"0", &test_object_tree_walk__0},
	{"1", &test_object_tree_walk__1}
};
static const struct clar_func _clar_cb_object_tree_write[] = {
    {"from_memory", &test_object_tree_write__from_memory},
	{"sorted_subtrees", &test_object_tree_write__sorted_subtrees},
	{"subtree", &test_object_tree_write__subtree}
};
static const struct clar_func _clar_cb_odb_alternates[] = {
    {"chained", &test_odb_alternates__chained},
	{"long_chain", &test_odb_alternates__long_chain}
};
static const struct clar_func _clar_cb_odb_foreach[] = {
    {"foreach", &test_odb_foreach__foreach},
	{"interrupt_foreach", &test_odb_foreach__interrupt_foreach},
	{"one_pack", &test_odb_foreach__one_pack}
};
static const struct clar_func _clar_cb_odb_loose[] = {
    {"exists", &test_odb_loose__exists},
	{"simple_reads", &test_odb_loose__simple_reads}
};
static const struct clar_func _clar_cb_odb_mixed[] = {
    {"dup_oid", &test_odb_mixed__dup_oid}
};
static const struct clar_func _clar_cb_odb_packed[] = {
    {"mass_read", &test_odb_packed__mass_read},
	{"read_header_0", &test_odb_packed__read_header_0},
	{"read_header_1", &test_odb_packed__read_header_1}
};
static const struct clar_func _clar_cb_odb_packed_one[] = {
    {"mass_read", &test_odb_packed_one__mass_read},
	{"read_header_0", &test_odb_packed_one__read_header_0}
};
static const struct clar_func _clar_cb_odb_sorting[] = {
    {"alternate_backends_sorting", &test_odb_sorting__alternate_backends_sorting},
	{"basic_backends_sorting", &test_odb_sorting__basic_backends_sorting}
};
static const struct clar_func _clar_cb_pack_packbuilder[] = {
    {"create_pack", &test_pack_packbuilder__create_pack},
	{"foreach", &test_pack_packbuilder__foreach}
};
static const struct clar_func _clar_cb_refs_branches_create[] = {
    {"can_create_a_local_branch", &test_refs_branches_create__can_create_a_local_branch},
	{"can_force_create_over_an_existing_branch", &test_refs_branches_create__can_force_create_over_an_existing_branch},
	{"can_not_create_a_branch_if_its_name_collide_with_an_existing_one", &test_refs_branches_create__can_not_create_a_branch_if_its_name_collide_with_an_existing_one}
};
static const struct clar_func _clar_cb_refs_branches_delete[] = {
    {"can_delete_a_branch_even_if_HEAD_is_missing", &test_refs_branches_delete__can_delete_a_branch_even_if_HEAD_is_missing},
	{"can_delete_a_branch_pointed_at_by_detached_HEAD", &test_refs_branches_delete__can_delete_a_branch_pointed_at_by_detached_HEAD},
	{"can_delete_a_branch_when_HEAD_is_orphaned", &test_refs_branches_delete__can_delete_a_branch_when_HEAD_is_orphaned},
	{"can_delete_a_local_branch", &test_refs_branches_delete__can_delete_a_local_branch},
	{"can_delete_a_remote_branch", &test_refs_branches_delete__can_delete_a_remote_branch},
	{"can_not_delete_a_branch_pointed_at_by_HEAD", &test_refs_branches_delete__can_not_delete_a_branch_pointed_at_by_HEAD},
	{"deleting_a_branch_removes_related_configuration_data", &test_refs_branches_delete__deleting_a_branch_removes_related_configuration_data}
};
static const struct clar_func _clar_cb_refs_branches_foreach[] = {
    {"can_cancel", &test_refs_branches_foreach__can_cancel},
	{"retrieve_all_branches", &test_refs_branches_foreach__retrieve_all_branches},
	{"retrieve_local_branches", &test_refs_branches_foreach__retrieve_local_branches},
	{"retrieve_remote_branches", &test_refs_branches_foreach__retrieve_remote_branches},
	{"retrieve_remote_symbolic_HEAD_when_present", &test_refs_branches_foreach__retrieve_remote_symbolic_HEAD_when_present}
};
static const struct clar_func _clar_cb_refs_branches_ishead[] = {
    {"can_properly_handle_missing_HEAD", &test_refs_branches_ishead__can_properly_handle_missing_HEAD},
	{"can_properly_handle_orphaned_HEAD", &test_refs_branches_ishead__can_properly_handle_orphaned_HEAD},
	{"can_tell_if_a_branch_is_not_pointed_at_by_HEAD", &test_refs_branches_ishead__can_tell_if_a_branch_is_not_pointed_at_by_HEAD},
	{"can_tell_if_a_branch_is_pointed_at_by_HEAD", &test_refs_branches_ishead__can_tell_if_a_branch_is_pointed_at_by_HEAD},
	{"only_direct_references_are_considered", &test_refs_branches_ishead__only_direct_references_are_considered},
	{"wont_be_fooled_by_a_non_branch", &test_refs_branches_ishead__wont_be_fooled_by_a_non_branch}
};
static const struct clar_func _clar_cb_refs_branches_lookup[] = {
    {"can_retrieve_a_local_branch", &test_refs_branches_lookup__can_retrieve_a_local_branch},
	{"can_retrieve_a_remote_tracking_branch", &test_refs_branches_lookup__can_retrieve_a_remote_tracking_branch},
	{"trying_to_retrieve_an_unknown_branch_returns_ENOTFOUND", &test_refs_branches_lookup__trying_to_retrieve_an_unknown_branch_returns_ENOTFOUND}
};
static const struct clar_func _clar_cb_refs_branches_move[] = {
    {"can_force_move_over_an_existing_branch", &test_refs_branches_move__can_force_move_over_an_existing_branch},
	{"can_move_a_local_branch", &test_refs_branches_move__can_move_a_local_branch},
	{"can_move_a_local_branch_to_a_different_namespace", &test_refs_branches_move__can_move_a_local_branch_to_a_different_namespace},
	{"can_move_a_local_branch_to_a_partially_colliding_namespace", &test_refs_branches_move__can_move_a_local_branch_to_a_partially_colliding_namespace},
	{"can_not_move_a_branch_if_its_destination_name_collide_with_an_existing_one", &test_refs_branches_move__can_not_move_a_branch_if_its_destination_name_collide_with_an_existing_one},
	{"can_not_move_a_non_branch", &test_refs_branches_move__can_not_move_a_non_branch},
	{"moving_a_branch_moves_related_configuration_data", &test_refs_branches_move__moving_a_branch_moves_related_configuration_data},
	{"moving_the_branch_pointed_at_by_HEAD_updates_HEAD", &test_refs_branches_move__moving_the_branch_pointed_at_by_HEAD_updates_HEAD}
};
static const struct clar_func _clar_cb_refs_branches_tracking[] = {
    {"can_retrieve_the_local_tracking_reference_of_a_local_branch", &test_refs_branches_tracking__can_retrieve_the_local_tracking_reference_of_a_local_branch},
	{"can_retrieve_the_remote_tracking_reference_of_a_local_branch", &test_refs_branches_tracking__can_retrieve_the_remote_tracking_reference_of_a_local_branch},
	{"cannot_retrieve_a_remote_tracking_reference_from_a_non_branch", &test_refs_branches_tracking__cannot_retrieve_a_remote_tracking_reference_from_a_non_branch},
	{"trying_to_retrieve_a_remote_tracking_reference_from_a_branch_with_no_fetchspec_returns_GIT_ENOTFOUND", &test_refs_branches_tracking__trying_to_retrieve_a_remote_tracking_reference_from_a_branch_with_no_fetchspec_returns_GIT_ENOTFOUND},
	{"trying_to_retrieve_a_remote_tracking_reference_from_a_plain_local_branch_returns_GIT_ENOTFOUND", &test_refs_branches_tracking__trying_to_retrieve_a_remote_tracking_reference_from_a_plain_local_branch_returns_GIT_ENOTFOUND}
};
static const struct clar_func _clar_cb_refs_crashes[] = {
    {"double_free", &test_refs_crashes__double_free}
};
static const struct clar_func _clar_cb_refs_create[] = {
    {"deep_symbolic", &test_refs_create__deep_symbolic},
	{"oid", &test_refs_create__oid},
	{"oid_unknown", &test_refs_create__oid_unknown},
	{"propagate_eexists", &test_refs_create__propagate_eexists},
	{"symbolic", &test_refs_create__symbolic}
};
static const struct clar_func _clar_cb_refs_delete[] = {
    {"packed_loose", &test_refs_delete__packed_loose},
	{"packed_only", &test_refs_delete__packed_only}
};
static const struct clar_func _clar_cb_refs_foreachglob[] = {
    {"can_cancel", &test_refs_foreachglob__can_cancel},
	{"retrieve_all_refs", &test_refs_foreachglob__retrieve_all_refs},
	{"retrieve_local_branches", &test_refs_foreachglob__retrieve_local_branches},
	{"retrieve_partially_named_references", &test_refs_foreachglob__retrieve_partially_named_references},
	{"retrieve_remote_branches", &test_refs_foreachglob__retrieve_remote_branches}
};
static const struct clar_func _clar_cb_refs_isvalidname[] = {
    {"can_detect_invalid_formats", &test_refs_isvalidname__can_detect_invalid_formats},
	{"wont_hopefully_choke_on_valid_formats", &test_refs_isvalidname__wont_hopefully_choke_on_valid_formats}
};
static const struct clar_func _clar_cb_refs_list[] = {
    {"all", &test_refs_list__all},
	{"do_not_retrieve_references_which_name_end_with_a_lock_extension", &test_refs_list__do_not_retrieve_references_which_name_end_with_a_lock_extension},
	{"symbolic_only", &test_refs_list__symbolic_only}
};
static const struct clar_func _clar_cb_refs_listall[] = {
    {"from_repository_opened_through_gitdir_path", &test_refs_listall__from_repository_opened_through_gitdir_path},
	{"from_repository_opened_through_workdir_path", &test_refs_listall__from_repository_opened_through_workdir_path}
};
static const struct clar_func _clar_cb_refs_lookup[] = {
    {"oid", &test_refs_lookup__oid},
	{"with_resolve", &test_refs_lookup__with_resolve}
};
static const struct clar_func _clar_cb_refs_normalize[] = {
    {"buffer_has_to_be_big_enough_to_hold_the_normalized_version", &test_refs_normalize__buffer_has_to_be_big_enough_to_hold_the_normalized_version},
	{"can_normalize_a_direct_reference_name", &test_refs_normalize__can_normalize_a_direct_reference_name},
	{"cannot_normalize_any_direct_reference_name", &test_refs_normalize__cannot_normalize_any_direct_reference_name},
	{"jgit_suite", &test_refs_normalize__jgit_suite},
	{"refspec_pattern", &test_refs_normalize__refspec_pattern},
	{"symbolic", &test_refs_normalize__symbolic}
};
static const struct clar_func _clar_cb_refs_overwrite[] = {
    {"object_id", &test_refs_overwrite__object_id},
	{"object_id_with_symbolic", &test_refs_overwrite__object_id_with_symbolic},
	{"symbolic", &test_refs_overwrite__symbolic},
	{"symbolic_with_object_id", &test_refs_overwrite__symbolic_with_object_id}
};
static const struct clar_func _clar_cb_refs_pack[] = {
    {"empty", &test_refs_pack__empty},
	{"loose", &test_refs_pack__loose}
};
static const struct clar_func _clar_cb_refs_peel[] = {
    {"can_peel_a_branch", &test_refs_peel__can_peel_a_branch},
	{"can_peel_a_symbolic_reference", &test_refs_peel__can_peel_a_symbolic_reference},
	{"can_peel_a_tag", &test_refs_peel__can_peel_a_tag},
	{"can_peel_into_any_non_tag_object", &test_refs_peel__can_peel_into_any_non_tag_object},
	{"cannot_peel_into_a_non_existing_target", &test_refs_peel__cannot_peel_into_a_non_existing_target}
};
static const struct clar_func _clar_cb_refs_read[] = {
    {"can_determine_if_a_reference_is_a_local_branch", &test_refs_read__can_determine_if_a_reference_is_a_local_branch},
	{"chomped", &test_refs_read__chomped},
	{"head_then_master", &test_refs_read__head_then_master},
	{"loose_first", &test_refs_read__loose_first},
	{"loose_tag", &test_refs_read__loose_tag},
	{"master_then_head", &test_refs_read__master_then_head},
	{"nested_symbolic", &test_refs_read__nested_symbolic},
	{"nonexisting_tag", &test_refs_read__nonexisting_tag},
	{"packed", &test_refs_read__packed},
	{"symbolic", &test_refs_read__symbolic},
	{"trailing", &test_refs_read__trailing},
	{"unfound_return_ENOTFOUND", &test_refs_read__unfound_return_ENOTFOUND}
};
static const struct clar_func _clar_cb_refs_reflog_drop[] = {
    {"can_drop_all_the_entries", &test_refs_reflog_drop__can_drop_all_the_entries},
	{"can_drop_an_entry", &test_refs_reflog_drop__can_drop_an_entry},
	{"can_drop_an_entry_and_rewrite_the_log_history", &test_refs_reflog_drop__can_drop_an_entry_and_rewrite_the_log_history},
	{"can_drop_the_oldest_entry", &test_refs_reflog_drop__can_drop_the_oldest_entry},
	{"can_drop_the_oldest_entry_and_rewrite_the_log_history", &test_refs_reflog_drop__can_drop_the_oldest_entry_and_rewrite_the_log_history},
	{"can_persist_deletion_on_disk", &test_refs_reflog_drop__can_persist_deletion_on_disk},
	{"dropping_a_non_exisiting_entry_from_the_log_returns_ENOTFOUND", &test_refs_reflog_drop__dropping_a_non_exisiting_entry_from_the_log_returns_ENOTFOUND}
};
static const struct clar_func _clar_cb_refs_reflog_reflog[] = {
    {"append_then_read", &test_refs_reflog_reflog__append_then_read},
	{"cannot_write_a_moved_reflog", &test_refs_reflog_reflog__cannot_write_a_moved_reflog},
	{"reading_the_reflog_from_a_reference_with_no_log_returns_an_empty_one", &test_refs_reflog_reflog__reading_the_reflog_from_a_reference_with_no_log_returns_an_empty_one},
	{"reference_has_reflog", &test_refs_reflog_reflog__reference_has_reflog},
	{"renaming_the_reference_moves_the_reflog", &test_refs_reflog_reflog__renaming_the_reference_moves_the_reflog}
};
static const struct clar_func _clar_cb_refs_rename[] = {
    {"force_loose", &test_refs_rename__force_loose},
	{"force_loose_packed", &test_refs_rename__force_loose_packed},
	{"invalid_name", &test_refs_rename__invalid_name},
	{"loose", &test_refs_rename__loose},
	{"move_up", &test_refs_rename__move_up},
	{"name_collision", &test_refs_rename__name_collision},
	{"overwrite", &test_refs_rename__overwrite},
	{"packed", &test_refs_rename__packed},
	{"packed_doesnt_pack_others", &test_refs_rename__packed_doesnt_pack_others},
	{"prefix", &test_refs_rename__prefix},
	{"propagate_eexists", &test_refs_rename__propagate_eexists}
};
static const struct clar_func _clar_cb_refs_revparse[] = {
    {"a_too_short_objectid_returns_EAMBIGUOUS", &test_refs_revparse__a_too_short_objectid_returns_EAMBIGUOUS},
	{"chaining", &test_refs_revparse__chaining},
	{"colon", &test_refs_revparse__colon},
	{"date", &test_refs_revparse__date},
	{"describe_output", &test_refs_revparse__describe_output},
	{"disambiguation", &test_refs_revparse__disambiguation},
	{"full_refs", &test_refs_revparse__full_refs},
	{"head", &test_refs_revparse__head},
	{"invalid_reference_name", &test_refs_revparse__invalid_reference_name},
	{"issue_994", &test_refs_revparse__issue_994},
	{"linear_history", &test_refs_revparse__linear_history},
	{"nonexistant_object", &test_refs_revparse__nonexistant_object},
	{"not_tag", &test_refs_revparse__not_tag},
	{"nth_parent", &test_refs_revparse__nth_parent},
	{"ordinal", &test_refs_revparse__ordinal},
	{"partial_refs", &test_refs_revparse__partial_refs},
	{"previous_head", &test_refs_revparse__previous_head},
	{"reflog_of_a_ref_under_refs", &test_refs_revparse__reflog_of_a_ref_under_refs},
	{"revwalk", &test_refs_revparse__revwalk},
	{"shas", &test_refs_revparse__shas},
	{"to_type", &test_refs_revparse__to_type},
	{"upstream", &test_refs_revparse__upstream}
};
static const struct clar_func _clar_cb_refs_unicode[] = {
    {"create_and_lookup", &test_refs_unicode__create_and_lookup}
};
static const struct clar_func _clar_cb_repo_discover[] = {
    {"0", &test_repo_discover__0}
};
static const struct clar_func _clar_cb_repo_getters[] = {
    {"is_empty_can_detect_used_repositories", &test_repo_getters__is_empty_can_detect_used_repositories},
	{"is_empty_correctly_deals_with_pristine_looking_repos", &test_repo_getters__is_empty_correctly_deals_with_pristine_looking_repos},
	{"retrieving_the_odb_honors_the_refcount", &test_repo_getters__retrieving_the_odb_honors_the_refcount}
};
static const struct clar_func _clar_cb_repo_hashfile[] = {
    {"filtered", &test_repo_hashfile__filtered},
	{"simple", &test_repo_hashfile__simple}
};
static const struct clar_func _clar_cb_repo_head[] = {
    {"can_tell_if_an_orphaned_head_is_detached", &test_repo_head__can_tell_if_an_orphaned_head_is_detached},
	{"detach_head_Detaches_HEAD_and_make_it_point_to_the_peeled_commit", &test_repo_head__detach_head_Detaches_HEAD_and_make_it_point_to_the_peeled_commit},
	{"detach_head_Fails_if_HEAD_and_point_to_a_non_commitish", &test_repo_head__detach_head_Fails_if_HEAD_and_point_to_a_non_commitish},
	{"detaching_an_orphaned_head_returns_GIT_EORPHANEDHEAD", &test_repo_head__detaching_an_orphaned_head_returns_GIT_EORPHANEDHEAD},
	{"head_detached", &test_repo_head__head_detached},
	{"head_orphan", &test_repo_head__head_orphan},
	{"retrieving_a_missing_head_returns_GIT_ENOTFOUND", &test_repo_head__retrieving_a_missing_head_returns_GIT_ENOTFOUND},
	{"retrieving_an_orphaned_head_returns_GIT_EORPHANEDHEAD", &test_repo_head__retrieving_an_orphaned_head_returns_GIT_EORPHANEDHEAD},
	{"set_head_Attaches_HEAD_to_un_unborn_branch_when_the_branch_doesnt_exist", &test_repo_head__set_head_Attaches_HEAD_to_un_unborn_branch_when_the_branch_doesnt_exist},
	{"set_head_Attaches_HEAD_when_the_reference_points_to_a_branch", &test_repo_head__set_head_Attaches_HEAD_when_the_reference_points_to_a_branch},
	{"set_head_Detaches_HEAD_when_the_reference_doesnt_point_to_a_branch", &test_repo_head__set_head_Detaches_HEAD_when_the_reference_doesnt_point_to_a_branch},
	{"set_head_Fails_when_the_reference_points_to_a_non_commitish", &test_repo_head__set_head_Fails_when_the_reference_points_to_a_non_commitish},
	{"set_head_Returns_ENOTFOUND_when_the_reference_doesnt_exist", &test_repo_head__set_head_Returns_ENOTFOUND_when_the_reference_doesnt_exist},
	{"set_head_detached_Detaches_HEAD_and_make_it_point_to_the_peeled_commit", &test_repo_head__set_head_detached_Detaches_HEAD_and_make_it_point_to_the_peeled_commit},
	{"set_head_detached_Fails_when_the_object_isnt_a_commitish", &test_repo_head__set_head_detached_Fails_when_the_object_isnt_a_commitish},
	{"set_head_detached_Return_ENOTFOUND_when_the_object_doesnt_exist", &test_repo_head__set_head_detached_Return_ENOTFOUND_when_the_object_doesnt_exist}
};
static const struct clar_func _clar_cb_repo_headtree[] = {
    {"can_retrieve_the_root_tree_from_a_detached_head", &test_repo_headtree__can_retrieve_the_root_tree_from_a_detached_head},
	{"can_retrieve_the_root_tree_from_a_non_detached_head", &test_repo_headtree__can_retrieve_the_root_tree_from_a_non_detached_head},
	{"when_head_is_missing_returns_ENOTFOUND", &test_repo_headtree__when_head_is_missing_returns_ENOTFOUND},
	{"when_head_is_orphaned_returns_EORPHANEDHEAD", &test_repo_headtree__when_head_is_orphaned_returns_EORPHANEDHEAD}
};
static const struct clar_func _clar_cb_repo_init[] = {
    {"additional_templates", &test_repo_init__additional_templates},
	{"bare_repo", &test_repo_init__bare_repo},
	{"bare_repo_escaping_current_workdir", &test_repo_init__bare_repo_escaping_current_workdir},
	{"bare_repo_noslash", &test_repo_init__bare_repo_noslash},
	{"can_reinit_an_initialized_repository", &test_repo_init__can_reinit_an_initialized_repository},
	{"detect_filemode", &test_repo_init__detect_filemode},
	{"detect_ignorecase", &test_repo_init__detect_ignorecase},
	{"extended_0", &test_repo_init__extended_0},
	{"extended_1", &test_repo_init__extended_1},
	{"extended_with_template", &test_repo_init__extended_with_template},
	{"reinit_bare_repo", &test_repo_init__reinit_bare_repo},
	{"reinit_doesnot_overwrite_ignorecase", &test_repo_init__reinit_doesnot_overwrite_ignorecase},
	{"reinit_overwrites_filemode", &test_repo_init__reinit_overwrites_filemode},
	{"reinit_too_recent_bare_repo", &test_repo_init__reinit_too_recent_bare_repo},
	{"sets_logAllRefUpdates_according_to_type_of_repository", &test_repo_init__sets_logAllRefUpdates_according_to_type_of_repository},
	{"standard_repo", &test_repo_init__standard_repo},
	{"standard_repo_noslash", &test_repo_init__standard_repo_noslash}
};
static const struct clar_func _clar_cb_repo_message[] = {
    {"message", &test_repo_message__message},
	{"none", &test_repo_message__none}
};
static const struct clar_func _clar_cb_repo_open[] = {
    {"bad_gitlinks", &test_repo_open__bad_gitlinks},
	{"bare_empty_repo", &test_repo_open__bare_empty_repo},
	{"failures", &test_repo_open__failures},
	{"from_git_new_workdir", &test_repo_open__from_git_new_workdir},
	{"gitlinked", &test_repo_open__gitlinked},
	{"open_with_discover", &test_repo_open__open_with_discover},
	{"opening_a_non_existing_repository_returns_ENOTFOUND", &test_repo_open__opening_a_non_existing_repository_returns_ENOTFOUND},
	{"standard_empty_repo_through_gitdir", &test_repo_open__standard_empty_repo_through_gitdir},
	{"standard_empty_repo_through_workdir", &test_repo_open__standard_empty_repo_through_workdir},
	{"win32_path", &test_repo_open__win32_path}
};
static const struct clar_func _clar_cb_repo_setters[] = {
    {"setting_a_new_index_on_a_repo_which_has_already_loaded_one_properly_honors_the_refcount", &test_repo_setters__setting_a_new_index_on_a_repo_which_has_already_loaded_one_properly_honors_the_refcount},
	{"setting_a_new_odb_on_a_repo_which_already_loaded_one_properly_honors_the_refcount", &test_repo_setters__setting_a_new_odb_on_a_repo_which_already_loaded_one_properly_honors_the_refcount},
	{"setting_a_workdir_creates_a_gitlink", &test_repo_setters__setting_a_workdir_creates_a_gitlink},
	{"setting_a_workdir_prettifies_its_path", &test_repo_setters__setting_a_workdir_prettifies_its_path},
	{"setting_a_workdir_turns_a_bare_repository_into_a_standard_one", &test_repo_setters__setting_a_workdir_turns_a_bare_repository_into_a_standard_one}
};
static const struct clar_func _clar_cb_repo_state[] = {
    {"apply_mailbox", &test_repo_state__apply_mailbox},
	{"apply_mailbox_or_rebase", &test_repo_state__apply_mailbox_or_rebase},
	{"bisect", &test_repo_state__bisect},
	{"cherry_pick", &test_repo_state__cherry_pick},
	{"merge", &test_repo_state__merge},
	{"none_with_HEAD_attached", &test_repo_state__none_with_HEAD_attached},
	{"none_with_HEAD_detached", &test_repo_state__none_with_HEAD_detached},
	{"rebase", &test_repo_state__rebase},
	{"rebase_interactive", &test_repo_state__rebase_interactive},
	{"rebase_merge", &test_repo_state__rebase_merge},
	{"revert", &test_repo_state__revert}
};
static const struct clar_func _clar_cb_reset_hard[] = {
    {"cannot_reset_in_a_bare_repository", &test_reset_hard__cannot_reset_in_a_bare_repository},
	{"cleans_up_merge", &test_reset_hard__cleans_up_merge},
	{"resetting_reverts_modified_files", &test_reset_hard__resetting_reverts_modified_files}
};
static const struct clar_func _clar_cb_reset_mixed[] = {
    {"cannot_reset_in_a_bare_repository", &test_reset_mixed__cannot_reset_in_a_bare_repository},
	{"resetting_refreshes_the_index_to_the_commit_tree", &test_reset_mixed__resetting_refreshes_the_index_to_the_commit_tree}
};
static const struct clar_func _clar_cb_reset_soft[] = {
    {"can_reset_the_detached_Head_to_the_specified_commit", &test_reset_soft__can_reset_the_detached_Head_to_the_specified_commit},
	{"can_reset_the_non_detached_Head_to_the_specified_commit", &test_reset_soft__can_reset_the_non_detached_Head_to_the_specified_commit},
	{"cannot_reset_to_a_tag_not_pointing_at_a_commit", &test_reset_soft__cannot_reset_to_a_tag_not_pointing_at_a_commit},
	{"fails_when_merging", &test_reset_soft__fails_when_merging},
	{"resetting_against_an_orphaned_head_repo_makes_the_head_no_longer_orphaned", &test_reset_soft__resetting_against_an_orphaned_head_repo_makes_the_head_no_longer_orphaned},
	{"resetting_to_a_tag_sets_the_Head_to_the_peeled_commit", &test_reset_soft__resetting_to_a_tag_sets_the_Head_to_the_peeled_commit},
	{"resetting_to_the_commit_pointed_at_by_the_Head_does_not_change_the_target_of_the_Head", &test_reset_soft__resetting_to_the_commit_pointed_at_by_the_Head_does_not_change_the_target_of_the_Head}
};
static const struct clar_func _clar_cb_revwalk_basic[] = {
    {"disallow_non_commit", &test_revwalk_basic__disallow_non_commit},
	{"glob_heads", &test_revwalk_basic__glob_heads},
	{"push_head", &test_revwalk_basic__push_head},
	{"push_head_hide_ref", &test_revwalk_basic__push_head_hide_ref},
	{"push_head_hide_ref_nobase", &test_revwalk_basic__push_head_hide_ref_nobase},
	{"sorting_modes", &test_revwalk_basic__sorting_modes}
};
static const struct clar_func _clar_cb_revwalk_mergebase[] = {
    {"many_merge_branch", &test_revwalk_mergebase__many_merge_branch},
	{"many_no_common_ancestor_returns_ENOTFOUND", &test_revwalk_mergebase__many_no_common_ancestor_returns_ENOTFOUND},
	{"merged_branch", &test_revwalk_mergebase__merged_branch},
	{"no_common_ancestor_returns_ENOTFOUND", &test_revwalk_mergebase__no_common_ancestor_returns_ENOTFOUND},
	{"no_off_by_one_missing", &test_revwalk_mergebase__no_off_by_one_missing},
	{"single1", &test_revwalk_mergebase__single1},
	{"single2", &test_revwalk_mergebase__single2}
};
static const struct clar_func _clar_cb_revwalk_signatureparsing[] = {
    {"do_not_choke_when_name_contains_angle_brackets", &test_revwalk_signatureparsing__do_not_choke_when_name_contains_angle_brackets}
};
static const struct clar_func _clar_cb_stash_drop[] = {
    {"can_purge_the_stash_from_the_bottom", &test_stash_drop__can_purge_the_stash_from_the_bottom},
	{"can_purge_the_stash_from_the_top", &test_stash_drop__can_purge_the_stash_from_the_top},
	{"cannot_drop_a_non_existing_stashed_state", &test_stash_drop__cannot_drop_a_non_existing_stashed_state},
	{"cannot_drop_from_an_empty_stash", &test_stash_drop__cannot_drop_from_an_empty_stash},
	{"dropping_an_entry_rewrites_reflog_history", &test_stash_drop__dropping_an_entry_rewrites_reflog_history},
	{"dropping_the_last_entry_removes_the_stash", &test_stash_drop__dropping_the_last_entry_removes_the_stash}
};
static const struct clar_func _clar_cb_stash_foreach[] = {
    {"can_enumerate_a_repository", &test_stash_foreach__can_enumerate_a_repository},
	{"enumerating_a_empty_repository_doesnt_fail", &test_stash_foreach__enumerating_a_empty_repository_doesnt_fail}
};
static const struct clar_func _clar_cb_stash_save[] = {
    {"can_accept_a_message", &test_stash_save__can_accept_a_message},
	{"can_include_untracked_and_ignored_files", &test_stash_save__can_include_untracked_and_ignored_files},
	{"can_include_untracked_files", &test_stash_save__can_include_untracked_files},
	{"can_keep_index", &test_stash_save__can_keep_index},
	{"can_stage_normal_then_stage_untracked", &test_stash_save__can_stage_normal_then_stage_untracked},
	{"can_stash_against_a_detached_head", &test_stash_save__can_stash_against_a_detached_head},
	{"cannot_stash_against_a_bare_repository", &test_stash_save__cannot_stash_against_a_bare_repository},
	{"cannot_stash_against_an_unborn_branch", &test_stash_save__cannot_stash_against_an_unborn_branch},
	{"cannot_stash_when_there_are_no_local_change", &test_stash_save__cannot_stash_when_there_are_no_local_change},
	{"does_not_keep_index_by_default", &test_stash_save__does_not_keep_index_by_default},
	{"including_untracked_without_any_untracked_file_creates_an_empty_tree", &test_stash_save__including_untracked_without_any_untracked_file_creates_an_empty_tree},
	{"stashing_updates_the_reflog", &test_stash_save__stashing_updates_the_reflog}
};
static const struct clar_func _clar_cb_status_ignore[] = {
    {"0", &test_status_ignore__0},
	{"1", &test_status_ignore__1},
	{"add_internal_as_first_thing", &test_status_ignore__add_internal_as_first_thing},
	{"adding_internal_ignores", &test_status_ignore__adding_internal_ignores},
	{"empty_repo_with_gitignore_rewrite", &test_status_ignore__empty_repo_with_gitignore_rewrite},
	{"ignore_pattern_contains_space", &test_status_ignore__ignore_pattern_contains_space},
	{"ignore_pattern_ignorecase", &test_status_ignore__ignore_pattern_ignorecase},
	{"internal_ignores_inside_deep_paths", &test_status_ignore__internal_ignores_inside_deep_paths},
	{"subdirectories", &test_status_ignore__subdirectories}
};
static const struct clar_func _clar_cb_status_single[] = {
    {"hash_single_empty_file", &test_status_single__hash_single_empty_file},
	{"hash_single_file", &test_status_single__hash_single_file}
};
static const struct clar_func _clar_cb_status_submodules[] = {
    {"0", &test_status_submodules__0},
	{"1", &test_status_submodules__1},
	{"api", &test_status_submodules__api},
	{"single_file", &test_status_submodules__single_file}
};
static const struct clar_func _clar_cb_status_worktree[] = {
    {"bracket_in_filename", &test_status_worktree__bracket_in_filename},
	{"cannot_retrieve_the_status_of_a_bare_repository", &test_status_worktree__cannot_retrieve_the_status_of_a_bare_repository},
	{"disable_pathspec_match", &test_status_worktree__disable_pathspec_match},
	{"empty_repository", &test_status_worktree__empty_repository},
	{"filemode_changes", &test_status_worktree__filemode_changes},
	{"first_commit_in_progress", &test_status_worktree__first_commit_in_progress},
	{"ignores", &test_status_worktree__ignores},
	{"interruptable_foreach", &test_status_worktree__interruptable_foreach},
	{"issue_592", &test_status_worktree__issue_592},
	{"issue_592_2", &test_status_worktree__issue_592_2},
	{"issue_592_3", &test_status_worktree__issue_592_3},
	{"issue_592_4", &test_status_worktree__issue_592_4},
	{"issue_592_5", &test_status_worktree__issue_592_5},
	{"issue_592_ignored_dirs_with_tracked_content", &test_status_worktree__issue_592_ignored_dirs_with_tracked_content},
	{"issue_592_ignores_0", &test_status_worktree__issue_592_ignores_0},
	{"line_endings_dont_count_as_changes_with_autocrlf", &test_status_worktree__line_endings_dont_count_as_changes_with_autocrlf},
	{"new_staged_file_must_handle_crlf", &test_status_worktree__new_staged_file_must_handle_crlf},
	{"purged_worktree", &test_status_worktree__purged_worktree},
	{"single_file", &test_status_worktree__single_file},
	{"single_file_empty_repo", &test_status_worktree__single_file_empty_repo},
	{"single_folder", &test_status_worktree__single_folder},
	{"single_nonexistent_file", &test_status_worktree__single_nonexistent_file},
	{"single_nonexistent_file_empty_repo", &test_status_worktree__single_nonexistent_file_empty_repo},
	{"space_in_filename", &test_status_worktree__space_in_filename},
	{"status_file_with_clean_index_and_empty_workdir", &test_status_worktree__status_file_with_clean_index_and_empty_workdir},
	{"status_file_without_index_or_workdir", &test_status_worktree__status_file_without_index_or_workdir},
	{"swap_subdir_and_file", &test_status_worktree__swap_subdir_and_file},
	{"swap_subdir_with_recurse_and_pathspec", &test_status_worktree__swap_subdir_with_recurse_and_pathspec},
	{"whole_repository", &test_status_worktree__whole_repository}
};
static const struct clar_func _clar_cb_submodule_lookup[] = {
    {"accessors", &test_submodule_lookup__accessors},
	{"foreach", &test_submodule_lookup__foreach},
	{"simple_lookup", &test_submodule_lookup__simple_lookup}
};
static const struct clar_func _clar_cb_submodule_modify[] = {
    {"add", &test_submodule_modify__add},
	{"edit_and_save", &test_submodule_modify__edit_and_save},
	{"init", &test_submodule_modify__init},
	{"sync", &test_submodule_modify__sync}
};
static const struct clar_func _clar_cb_submodule_status[] = {
    {"ignore_all", &test_submodule_status__ignore_all},
	{"ignore_dirty", &test_submodule_status__ignore_dirty},
	{"ignore_none", &test_submodule_status__ignore_none},
	{"ignore_untracked", &test_submodule_status__ignore_untracked},
	{"unchanged", &test_submodule_status__unchanged}
};
static const struct clar_func _clar_cb_threads_basic[] = {
    {"cache", &test_threads_basic__cache}
};

static const char *_clar_cat_clone_network[] = { "network", NULL };static const char *_clar_cat_fetchhead_network[] = { "network", NULL };static const char *_clar_cat_network_fetch[] = { "network", NULL };

static const struct clar_suite _clar_suites[] = {
    {
        0,
        "attr::file",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_attr_file, 4
    },
	{
        1,
        "attr::flags",
        {NULL, NULL},
        {"cleanup", &test_attr_flags__cleanup},
        NULL,
        _clar_cb_attr_flags, 3
    },
	{
        2,
        "attr::lookup",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_attr_lookup, 5
    },
	{
        3,
        "attr::repo",
        {"initialize", &test_attr_repo__initialize},
        {"cleanup", &test_attr_repo__cleanup},
        NULL,
        _clar_cb_attr_repo, 7
    },
	{
        4,
        "buf::basic",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_buf_basic, 2
    },
	{
        5,
        "buf::splice",
        {"initialize", &test_buf_splice__initialize},
        {"cleanup", &test_buf_splice__cleanup},
        NULL,
        _clar_cb_buf_splice, 9
    },
	{
        6,
        "checkout::head",
        {"initialize", &test_checkout_head__initialize},
        {"cleanup", &test_checkout_head__cleanup},
        NULL,
        _clar_cb_checkout_head, 1
    },
	{
        7,
        "checkout::index",
        {"initialize", &test_checkout_index__initialize},
        {"cleanup", &test_checkout_index__cleanup},
        NULL,
        _clar_cb_checkout_index, 18
    },
	{
        8,
        "checkout::tree",
        {"initialize", &test_checkout_tree__initialize},
        {"cleanup", &test_checkout_tree__cleanup},
        NULL,
        _clar_cb_checkout_tree, 4
    },
	{
        9,
        "checkout::typechange",
        {"initialize", &test_checkout_typechange__initialize},
        {"cleanup", &test_checkout_typechange__cleanup},
        NULL,
        _clar_cb_checkout_typechange, 1
    },
	{
        10,
        "clone::network",
        {"initialize", &test_clone_network__initialize},
        {NULL, NULL},
        _clar_cat_clone_network,
        _clar_cb_clone_network, 6
    },
	{
        11,
        "clone::nonetwork",
        {"initialize", &test_clone_nonetwork__initialize},
        {NULL, NULL},
        NULL,
        _clar_cb_clone_nonetwork, 5
    },
	{
        12,
        "commit::commit",
        {"initialize", &test_commit_commit__initialize},
        {"cleanup", &test_commit_commit__cleanup},
        NULL,
        _clar_cb_commit_commit, 1
    },
	{
        13,
        "commit::parent",
        {"initialize", &test_commit_parent__initialize},
        {"cleanup", &test_commit_parent__cleanup},
        NULL,
        _clar_cb_commit_parent, 1
    },
	{
        14,
        "commit::parse",
        {"initialize", &test_commit_parse__initialize},
        {"cleanup", &test_commit_parse__cleanup},
        NULL,
        _clar_cb_commit_parse, 4
    },
	{
        15,
        "commit::signature",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_commit_signature, 7
    },
	{
        16,
        "commit::write",
        {"initialize", &test_commit_write__initialize},
        {"cleanup", &test_commit_write__cleanup},
        NULL,
        _clar_cb_commit_write, 2
    },
	{
        17,
        "config::add",
        {"initialize", &test_config_add__initialize},
        {"cleanup", &test_config_add__cleanup},
        NULL,
        _clar_cb_config_add, 2
    },
	{
        18,
        "config::configlevel",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_config_configlevel, 4
    },
	{
        19,
        "config::multivar",
        {"initialize", &test_config_multivar__initialize},
        {"cleanup", &test_config_multivar__cleanup},
        NULL,
        _clar_cb_config_multivar, 5
    },
	{
        20,
        "config::new",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_config_new, 1
    },
	{
        21,
        "config::read",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_config_read, 21
    },
	{
        22,
        "config::refresh",
        {"initialize", &test_config_refresh__initialize},
        {"cleanup", &test_config_refresh__cleanup},
        NULL,
        _clar_cb_config_refresh, 2
    },
	{
        23,
        "config::stress",
        {"initialize", &test_config_stress__initialize},
        {"cleanup", &test_config_stress__cleanup},
        NULL,
        _clar_cb_config_stress, 3
    },
	{
        24,
        "config::write",
        {"initialize", &test_config_write__initialize},
        {"cleanup", &test_config_write__cleanup},
        NULL,
        _clar_cb_config_write, 9
    },
	{
        25,
        "core::buffer",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_core_buffer, 16
    },
	{
        26,
        "core::copy",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_core_copy, 3
    },
	{
        27,
        "core::dirent",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_core_dirent, 6
    },
	{
        28,
        "core::env",
        {"initialize", &test_core_env__initialize},
        {"cleanup", &test_core_env__cleanup},
        NULL,
        _clar_cb_core_env, 2
    },
	{
        29,
        "core::errors",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_core_errors, 2
    },
	{
        30,
        "core::filebuf",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_core_filebuf, 5
    },
	{
        31,
        "core::hex",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_core_hex, 1
    },
	{
        32,
        "core::mkdir",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_core_mkdir, 3
    },
	{
        33,
        "core::oid",
        {"initialize", &test_core_oid__initialize},
        {NULL, NULL},
        NULL,
        _clar_cb_core_oid, 1
    },
	{
        34,
        "core::path",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_core_path, 13
    },
	{
        35,
        "core::pool",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_core_pool, 3
    },
	{
        36,
        "core::rmdir",
        {"initialize", &test_core_rmdir__initialize},
        {NULL, NULL},
        NULL,
        _clar_cb_core_rmdir, 4
    },
	{
        37,
        "core::stat",
        {"initialize", &test_core_stat__initialize},
        {"cleanup", &test_core_stat__cleanup},
        NULL,
        _clar_cb_core_stat, 1
    },
	{
        38,
        "core::string",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_core_string, 2
    },
	{
        39,
        "core::strmap",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_core_strmap, 4
    },
	{
        40,
        "core::strtol",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_core_strtol, 2
    },
	{
        41,
        "core::vector",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_core_vector, 7
    },
	{
        42,
        "date::date",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_date_date, 1
    },
	{
        43,
        "diff::blob",
        {"initialize", &test_diff_blob__initialize},
        {"cleanup", &test_diff_blob__cleanup},
        NULL,
        _clar_cb_diff_blob, 6
    },
	{
        44,
        "diff::diffiter",
        {"initialize", &test_diff_diffiter__initialize},
        {"cleanup", &test_diff_diffiter__cleanup},
        NULL,
        _clar_cb_diff_diffiter, 8
    },
	{
        45,
        "diff::index",
        {"initialize", &test_diff_index__initialize},
        {"cleanup", &test_diff_index__cleanup},
        NULL,
        _clar_cb_diff_index, 2
    },
	{
        46,
        "diff::iterator",
        {"initialize", &test_diff_iterator__initialize},
        {"cleanup", &test_diff_iterator__cleanup},
        NULL,
        _clar_cb_diff_iterator, 28
    },
	{
        47,
        "diff::patch",
        {"initialize", &test_diff_patch__initialize},
        {"cleanup", &test_diff_patch__cleanup},
        NULL,
        _clar_cb_diff_patch, 2
    },
	{
        48,
        "diff::rename",
        {"initialize", &test_diff_rename__initialize},
        {"cleanup", &test_diff_rename__cleanup},
        NULL,
        _clar_cb_diff_rename, 1
    },
	{
        49,
        "diff::tree",
        {"initialize", &test_diff_tree__initialize},
        {"cleanup", &test_diff_tree__cleanup},
        NULL,
        _clar_cb_diff_tree, 5
    },
	{
        50,
        "diff::workdir",
        {"initialize", &test_diff_workdir__initialize},
        {"cleanup", &test_diff_workdir__cleanup},
        NULL,
        _clar_cb_diff_workdir, 10
    },
	{
        51,
        "fetchhead::network",
        {"initialize", &test_fetchhead_network__initialize},
        {NULL, NULL},
        _clar_cat_fetchhead_network,
        _clar_cb_fetchhead_network, 3
    },
	{
        52,
        "fetchhead::nonetwork",
        {"initialize", &test_fetchhead_nonetwork__initialize},
        {NULL, NULL},
        NULL,
        _clar_cb_fetchhead_nonetwork, 1
    },
	{
        53,
        "index::conflicts",
        {"initialize", &test_index_conflicts__initialize},
        {"cleanup", &test_index_conflicts__cleanup},
        NULL,
        _clar_cb_index_conflicts, 7
    },
	{
        54,
        "index::filemodes",
        {"initialize", &test_index_filemodes__initialize},
        {"cleanup", &test_index_filemodes__cleanup},
        NULL,
        _clar_cb_index_filemodes, 3
    },
	{
        55,
        "index::inmemory",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_index_inmemory, 2
    },
	{
        56,
        "index::read::tree",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_index_read_tree, 1
    },
	{
        57,
        "index::rename",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_index_rename, 1
    },
	{
        58,
        "index::reuc",
        {"initialize", &test_index_reuc__initialize},
        {"cleanup", &test_index_reuc__cleanup},
        NULL,
        _clar_cb_index_reuc, 6
    },
	{
        59,
        "index::stage",
        {"initialize", &test_index_stage__initialize},
        {"cleanup", &test_index_stage__cleanup},
        NULL,
        _clar_cb_index_stage, 2
    },
	{
        60,
        "index::tests",
        {"initialize", &test_index_tests__initialize},
        {"cleanup", &test_index_tests__cleanup},
        NULL,
        _clar_cb_index_tests, 11
    },
	{
        61,
        "network::createremotethenload",
        {"initialize", &test_network_createremotethenload__initialize},
        {"cleanup", &test_network_createremotethenload__cleanup},
        NULL,
        _clar_cb_network_createremotethenload, 1
    },
	{
        62,
        "network::fetch",
        {"initialize", &test_network_fetch__initialize},
        {"cleanup", &test_network_fetch__cleanup},
        _clar_cat_network_fetch,
        _clar_cb_network_fetch, 4
    },
	{
        63,
        "network::fetchlocal",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_network_fetchlocal, 2
    },
	{
        64,
        "network::refspecs",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_network_refspecs, 1
    },
	{
        65,
        "network::remotelocal",
        {"initialize", &test_network_remotelocal__initialize},
        {"cleanup", &test_network_remotelocal__cleanup},
        NULL,
        _clar_cb_network_remotelocal, 4
    },
	{
        66,
        "network::remoterename",
        {"initialize", &test_network_remoterename__initialize},
        {"cleanup", &test_network_remoterename__cleanup},
        NULL,
        _clar_cb_network_remoterename, 12
    },
	{
        67,
        "network::remotes",
        {"initialize", &test_network_remotes__initialize},
        {"cleanup", &test_network_remotes__cleanup},
        NULL,
        _clar_cb_network_remotes, 21
    },
	{
        68,
        "notes::notes",
        {"initialize", &test_notes_notes__initialize},
        {"cleanup", &test_notes_notes__cleanup},
        NULL,
        _clar_cb_notes_notes, 10
    },
	{
        69,
        "notes::notesref",
        {"initialize", &test_notes_notesref__initialize},
        {"cleanup", &test_notes_notesref__cleanup},
        NULL,
        _clar_cb_notes_notesref, 1
    },
	{
        70,
        "object::blob::filter",
        {"initialize", &test_object_blob_filter__initialize},
        {"cleanup", &test_object_blob_filter__cleanup},
        NULL,
        _clar_cb_object_blob_filter, 3
    },
	{
        71,
        "object::blob::fromchunks",
        {"initialize", &test_object_blob_fromchunks__initialize},
        {"cleanup", &test_object_blob_fromchunks__cleanup},
        NULL,
        _clar_cb_object_blob_fromchunks, 2
    },
	{
        72,
        "object::blob::write",
        {NULL, NULL},
        {"cleanup", &test_object_blob_write__cleanup},
        NULL,
        _clar_cb_object_blob_write, 3
    },
	{
        73,
        "object::commit::commitstagedfile",
        {"initialize", &test_object_commit_commitstagedfile__initialize},
        {"cleanup", &test_object_commit_commitstagedfile__cleanup},
        NULL,
        _clar_cb_object_commit_commitstagedfile, 1
    },
	{
        74,
        "object::lookup",
        {"initialize", &test_object_lookup__initialize},
        {"cleanup", &test_object_lookup__cleanup},
        NULL,
        _clar_cb_object_lookup, 4
    },
	{
        75,
        "object::message",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_object_message, 16
    },
	{
        76,
        "object::peel",
        {"initialize", &test_object_peel__initialize},
        {"cleanup", &test_object_peel__cleanup},
        NULL,
        _clar_cb_object_peel, 6
    },
	{
        77,
        "object::raw::chars",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_object_raw_chars, 2
    },
	{
        78,
        "object::raw::compare",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_object_raw_compare, 7
    },
	{
        79,
        "object::raw::convert",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_object_raw_convert, 2
    },
	{
        80,
        "object::raw::fromstr",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_object_raw_fromstr, 2
    },
	{
        81,
        "object::raw::hash",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_object_raw_hash, 11
    },
	{
        82,
        "object::raw::short",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_object_raw_short, 2
    },
	{
        83,
        "object::raw::size",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_object_raw_size, 1
    },
	{
        84,
        "object::raw::type2string",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_object_raw_type2string, 3
    },
	{
        85,
        "object::raw::write",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_object_raw_write, 7
    },
	{
        86,
        "object::tag::list",
        {"initialize", &test_object_tag_list__initialize},
        {"cleanup", &test_object_tag_list__cleanup},
        NULL,
        _clar_cb_object_tag_list, 2
    },
	{
        87,
        "object::tag::peel",
        {"initialize", &test_object_tag_peel__initialize},
        {"cleanup", &test_object_tag_peel__cleanup},
        NULL,
        _clar_cb_object_tag_peel, 3
    },
	{
        88,
        "object::tag::read",
        {"initialize", &test_object_tag_read__initialize},
        {"cleanup", &test_object_tag_read__cleanup},
        NULL,
        _clar_cb_object_tag_read, 3
    },
	{
        89,
        "object::tag::write",
        {"initialize", &test_object_tag_write__initialize},
        {"cleanup", &test_object_tag_write__cleanup},
        NULL,
        _clar_cb_object_tag_write, 6
    },
	{
        90,
        "object::tree::attributes",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_object_tree_attributes, 4
    },
	{
        91,
        "object::tree::duplicateentries",
        {"initialize", &test_object_tree_duplicateentries__initialize},
        {"cleanup", &test_object_tree_duplicateentries__cleanup},
        NULL,
        _clar_cb_object_tree_duplicateentries, 2
    },
	{
        92,
        "object::tree::frompath",
        {"initialize", &test_object_tree_frompath__initialize},
        {"cleanup", &test_object_tree_frompath__cleanup},
        NULL,
        _clar_cb_object_tree_frompath, 2
    },
	{
        93,
        "object::tree::read",
        {"initialize", &test_object_tree_read__initialize},
        {"cleanup", &test_object_tree_read__cleanup},
        NULL,
        _clar_cb_object_tree_read, 2
    },
	{
        94,
        "object::tree::walk",
        {"initialize", &test_object_tree_walk__initialize},
        {"cleanup", &test_object_tree_walk__cleanup},
        NULL,
        _clar_cb_object_tree_walk, 2
    },
	{
        95,
        "object::tree::write",
        {"initialize", &test_object_tree_write__initialize},
        {"cleanup", &test_object_tree_write__cleanup},
        NULL,
        _clar_cb_object_tree_write, 3
    },
	{
        96,
        "odb::alternates",
        {NULL, NULL},
        {"cleanup", &test_odb_alternates__cleanup},
        NULL,
        _clar_cb_odb_alternates, 2
    },
	{
        97,
        "odb::foreach",
        {NULL, NULL},
        {"cleanup", &test_odb_foreach__cleanup},
        NULL,
        _clar_cb_odb_foreach, 3
    },
	{
        98,
        "odb::loose",
        {"initialize", &test_odb_loose__initialize},
        {"cleanup", &test_odb_loose__cleanup},
        NULL,
        _clar_cb_odb_loose, 2
    },
	{
        99,
        "odb::mixed",
        {"initialize", &test_odb_mixed__initialize},
        {"cleanup", &test_odb_mixed__cleanup},
        NULL,
        _clar_cb_odb_mixed, 1
    },
	{
        100,
        "odb::packed",
        {"initialize", &test_odb_packed__initialize},
        {"cleanup", &test_odb_packed__cleanup},
        NULL,
        _clar_cb_odb_packed, 3
    },
	{
        101,
        "odb::packed::one",
        {"initialize", &test_odb_packed_one__initialize},
        {"cleanup", &test_odb_packed_one__cleanup},
        NULL,
        _clar_cb_odb_packed_one, 2
    },
	{
        102,
        "odb::sorting",
        {"initialize", &test_odb_sorting__initialize},
        {"cleanup", &test_odb_sorting__cleanup},
        NULL,
        _clar_cb_odb_sorting, 2
    },
	{
        103,
        "pack::packbuilder",
        {"initialize", &test_pack_packbuilder__initialize},
        {"cleanup", &test_pack_packbuilder__cleanup},
        NULL,
        _clar_cb_pack_packbuilder, 2
    },
	{
        104,
        "refs::branches::create",
        {"initialize", &test_refs_branches_create__initialize},
        {"cleanup", &test_refs_branches_create__cleanup},
        NULL,
        _clar_cb_refs_branches_create, 3
    },
	{
        105,
        "refs::branches::delete",
        {"initialize", &test_refs_branches_delete__initialize},
        {"cleanup", &test_refs_branches_delete__cleanup},
        NULL,
        _clar_cb_refs_branches_delete, 7
    },
	{
        106,
        "refs::branches::foreach",
        {"initialize", &test_refs_branches_foreach__initialize},
        {"cleanup", &test_refs_branches_foreach__cleanup},
        NULL,
        _clar_cb_refs_branches_foreach, 5
    },
	{
        107,
        "refs::branches::ishead",
        {"initialize", &test_refs_branches_ishead__initialize},
        {"cleanup", &test_refs_branches_ishead__cleanup},
        NULL,
        _clar_cb_refs_branches_ishead, 6
    },
	{
        108,
        "refs::branches::lookup",
        {"initialize", &test_refs_branches_lookup__initialize},
        {"cleanup", &test_refs_branches_lookup__cleanup},
        NULL,
        _clar_cb_refs_branches_lookup, 3
    },
	{
        109,
        "refs::branches::move",
        {"initialize", &test_refs_branches_move__initialize},
        {"cleanup", &test_refs_branches_move__cleanup},
        NULL,
        _clar_cb_refs_branches_move, 8
    },
	{
        110,
        "refs::branches::tracking",
        {"initialize", &test_refs_branches_tracking__initialize},
        {"cleanup", &test_refs_branches_tracking__cleanup},
        NULL,
        _clar_cb_refs_branches_tracking, 5
    },
	{
        111,
        "refs::crashes",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_refs_crashes, 1
    },
	{
        112,
        "refs::create",
        {"initialize", &test_refs_create__initialize},
        {"cleanup", &test_refs_create__cleanup},
        NULL,
        _clar_cb_refs_create, 5
    },
	{
        113,
        "refs::delete",
        {"initialize", &test_refs_delete__initialize},
        {"cleanup", &test_refs_delete__cleanup},
        NULL,
        _clar_cb_refs_delete, 2
    },
	{
        114,
        "refs::foreachglob",
        {"initialize", &test_refs_foreachglob__initialize},
        {"cleanup", &test_refs_foreachglob__cleanup},
        NULL,
        _clar_cb_refs_foreachglob, 5
    },
	{
        115,
        "refs::isvalidname",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_refs_isvalidname, 2
    },
	{
        116,
        "refs::list",
        {"initialize", &test_refs_list__initialize},
        {"cleanup", &test_refs_list__cleanup},
        NULL,
        _clar_cb_refs_list, 3
    },
	{
        117,
        "refs::listall",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_refs_listall, 2
    },
	{
        118,
        "refs::lookup",
        {"initialize", &test_refs_lookup__initialize},
        {"cleanup", &test_refs_lookup__cleanup},
        NULL,
        _clar_cb_refs_lookup, 2
    },
	{
        119,
        "refs::normalize",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_refs_normalize, 6
    },
	{
        120,
        "refs::overwrite",
        {"initialize", &test_refs_overwrite__initialize},
        {"cleanup", &test_refs_overwrite__cleanup},
        NULL,
        _clar_cb_refs_overwrite, 4
    },
	{
        121,
        "refs::pack",
        {"initialize", &test_refs_pack__initialize},
        {"cleanup", &test_refs_pack__cleanup},
        NULL,
        _clar_cb_refs_pack, 2
    },
	{
        122,
        "refs::peel",
        {"initialize", &test_refs_peel__initialize},
        {"cleanup", &test_refs_peel__cleanup},
        NULL,
        _clar_cb_refs_peel, 5
    },
	{
        123,
        "refs::read",
        {"initialize", &test_refs_read__initialize},
        {"cleanup", &test_refs_read__cleanup},
        NULL,
        _clar_cb_refs_read, 12
    },
	{
        124,
        "refs::reflog::drop",
        {"initialize", &test_refs_reflog_drop__initialize},
        {"cleanup", &test_refs_reflog_drop__cleanup},
        NULL,
        _clar_cb_refs_reflog_drop, 7
    },
	{
        125,
        "refs::reflog::reflog",
        {"initialize", &test_refs_reflog_reflog__initialize},
        {"cleanup", &test_refs_reflog_reflog__cleanup},
        NULL,
        _clar_cb_refs_reflog_reflog, 5
    },
	{
        126,
        "refs::rename",
        {"initialize", &test_refs_rename__initialize},
        {"cleanup", &test_refs_rename__cleanup},
        NULL,
        _clar_cb_refs_rename, 11
    },
	{
        127,
        "refs::revparse",
        {"initialize", &test_refs_revparse__initialize},
        {"cleanup", &test_refs_revparse__cleanup},
        NULL,
        _clar_cb_refs_revparse, 22
    },
	{
        128,
        "refs::unicode",
        {"initialize", &test_refs_unicode__initialize},
        {"cleanup", &test_refs_unicode__cleanup},
        NULL,
        _clar_cb_refs_unicode, 1
    },
	{
        129,
        "repo::discover",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_repo_discover, 1
    },
	{
        130,
        "repo::getters",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_repo_getters, 3
    },
	{
        131,
        "repo::hashfile",
        {"initialize", &test_repo_hashfile__initialize},
        {"cleanup", &test_repo_hashfile__cleanup},
        NULL,
        _clar_cb_repo_hashfile, 2
    },
	{
        132,
        "repo::head",
        {"initialize", &test_repo_head__initialize},
        {"cleanup", &test_repo_head__cleanup},
        NULL,
        _clar_cb_repo_head, 16
    },
	{
        133,
        "repo::headtree",
        {"initialize", &test_repo_headtree__initialize},
        {"cleanup", &test_repo_headtree__cleanup},
        NULL,
        _clar_cb_repo_headtree, 4
    },
	{
        134,
        "repo::init",
        {"initialize", &test_repo_init__initialize},
        {NULL, NULL},
        NULL,
        _clar_cb_repo_init, 17
    },
	{
        135,
        "repo::message",
        {"initialize", &test_repo_message__initialize},
        {"cleanup", &test_repo_message__cleanup},
        NULL,
        _clar_cb_repo_message, 2
    },
	{
        136,
        "repo::open",
        {NULL, NULL},
        {"cleanup", &test_repo_open__cleanup},
        NULL,
        _clar_cb_repo_open, 10
    },
	{
        137,
        "repo::setters",
        {"initialize", &test_repo_setters__initialize},
        {"cleanup", &test_repo_setters__cleanup},
        NULL,
        _clar_cb_repo_setters, 5
    },
	{
        138,
        "repo::state",
        {"initialize", &test_repo_state__initialize},
        {"cleanup", &test_repo_state__cleanup},
        NULL,
        _clar_cb_repo_state, 11
    },
	{
        139,
        "reset::hard",
        {"initialize", &test_reset_hard__initialize},
        {"cleanup", &test_reset_hard__cleanup},
        NULL,
        _clar_cb_reset_hard, 3
    },
	{
        140,
        "reset::mixed",
        {"initialize", &test_reset_mixed__initialize},
        {"cleanup", &test_reset_mixed__cleanup},
        NULL,
        _clar_cb_reset_mixed, 2
    },
	{
        141,
        "reset::soft",
        {"initialize", &test_reset_soft__initialize},
        {"cleanup", &test_reset_soft__cleanup},
        NULL,
        _clar_cb_reset_soft, 7
    },
	{
        142,
        "revwalk::basic",
        {"initialize", &test_revwalk_basic__initialize},
        {"cleanup", &test_revwalk_basic__cleanup},
        NULL,
        _clar_cb_revwalk_basic, 6
    },
	{
        143,
        "revwalk::mergebase",
        {"initialize", &test_revwalk_mergebase__initialize},
        {"cleanup", &test_revwalk_mergebase__cleanup},
        NULL,
        _clar_cb_revwalk_mergebase, 7
    },
	{
        144,
        "revwalk::signatureparsing",
        {"initialize", &test_revwalk_signatureparsing__initialize},
        {"cleanup", &test_revwalk_signatureparsing__cleanup},
        NULL,
        _clar_cb_revwalk_signatureparsing, 1
    },
	{
        145,
        "stash::drop",
        {"initialize", &test_stash_drop__initialize},
        {"cleanup", &test_stash_drop__cleanup},
        NULL,
        _clar_cb_stash_drop, 6
    },
	{
        146,
        "stash::foreach",
        {"initialize", &test_stash_foreach__initialize},
        {"cleanup", &test_stash_foreach__cleanup},
        NULL,
        _clar_cb_stash_foreach, 2
    },
	{
        147,
        "stash::save",
        {"initialize", &test_stash_save__initialize},
        {"cleanup", &test_stash_save__cleanup},
        NULL,
        _clar_cb_stash_save, 12
    },
	{
        148,
        "status::ignore",
        {"initialize", &test_status_ignore__initialize},
        {"cleanup", &test_status_ignore__cleanup},
        NULL,
        _clar_cb_status_ignore, 9
    },
	{
        149,
        "status::single",
        {NULL, NULL},
        {NULL, NULL},
        NULL,
        _clar_cb_status_single, 2
    },
	{
        150,
        "status::submodules",
        {"initialize", &test_status_submodules__initialize},
        {"cleanup", &test_status_submodules__cleanup},
        NULL,
        _clar_cb_status_submodules, 4
    },
	{
        151,
        "status::worktree",
        {"initialize", &test_status_worktree__initialize},
        {"cleanup", &test_status_worktree__cleanup},
        NULL,
        _clar_cb_status_worktree, 29
    },
	{
        152,
        "submodule::lookup",
        {"initialize", &test_submodule_lookup__initialize},
        {"cleanup", &test_submodule_lookup__cleanup},
        NULL,
        _clar_cb_submodule_lookup, 3
    },
	{
        153,
        "submodule::modify",
        {"initialize", &test_submodule_modify__initialize},
        {"cleanup", &test_submodule_modify__cleanup},
        NULL,
        _clar_cb_submodule_modify, 4
    },
	{
        154,
        "submodule::status",
        {"initialize", &test_submodule_status__initialize},
        {"cleanup", &test_submodule_status__cleanup},
        NULL,
        _clar_cb_submodule_status, 5
    },
	{
        155,
        "threads::basic",
        {"initialize", &test_threads_basic__initialize},
        {"cleanup", &test_threads_basic__cleanup},
        NULL,
        _clar_cb_threads_basic, 1
    }
};

static size_t _clar_suite_count = 156;
static size_t _clar_callback_count = 784;

/* Core test functions */
static void
clar_report_errors(void)
{
	int i = 1;
	struct clar_error *error, *next;

	error = _clar.errors;
	while (error != NULL) {
		next = error->next;
		clar_print_error(i++, error);
		free(error->description);
		free(error);
		error = next;
	}

	_clar.errors = _clar.last_error = NULL;
}

static void
clar_run_test(
	const struct clar_func *test,
	const struct clar_func *initialize,
	const struct clar_func *cleanup)
{
	int error_st = _clar.suite_errors;

	clar_on_test();
	_clar.trampoline_enabled = 1;

	if (setjmp(_clar.trampoline) == 0) {
		if (initialize->ptr != NULL)
			initialize->ptr();

		test->ptr();
	}

	_clar.trampoline_enabled = 0;

	if (_clar.local_cleanup != NULL)
		_clar.local_cleanup(_clar.local_cleanup_payload);

	if (cleanup->ptr != NULL)
		cleanup->ptr();

	_clar.test_count++;

	/* remove any local-set cleanup methods */
	_clar.local_cleanup = NULL;
	_clar.local_cleanup_payload = NULL;

	if (_clar.report_errors_only)
		clar_report_errors();
	else
		clar_print_ontest(
			test->name,
			_clar.test_count,
			(_clar.suite_errors > error_st)
			);
}

static void
clar_run_suite(const struct clar_suite *suite)
{
	const struct clar_func *test = suite->tests;
	size_t i;

	if (!clar_category_is_suite_enabled(suite))
		return;

	if (_clar.exit_on_error && _clar.total_errors)
		return;

	if (!_clar.report_errors_only)
		clar_print_onsuite(suite->name, suite->index);
	clar_on_suite();

	_clar.active_suite = suite->name;
	_clar.suite_errors = 0;

	for (i = 0; i < suite->test_count; ++i) {
		_clar.active_test = test[i].name;
		clar_run_test(&test[i], &suite->initialize, &suite->cleanup);

		if (_clar.exit_on_error && _clar.total_errors)
			return;
	}
}

#if 0 /* temporarily disabled */
static void
clar_run_single(const struct clar_func *test,
	const struct clar_suite *suite)
{
	_clar.suite_errors = 0;
	_clar.active_suite = suite->name;
	_clar.active_test = test->name;

	clar_run_test(test, &suite->initialize, &suite->cleanup);
}
#endif

static void
clar_usage(const char *arg)
{
	printf("Usage: %s [options]\n\n", arg);
	printf("Options:\n");
	printf("  -sXX\t\tRun only the suite number or name XX\n");
	printf("  -i<name>\tInclude category <name> tests\n");
	printf("  -q  \t\tOnly report tests that had an error\n");
	printf("  -Q  \t\tQuit as soon as a test fails\n");
	printf("  -l  \t\tPrint suite names and category names\n");
	exit(-1);
}

static void
clar_parse_args(int argc, char **argv)
{
	int i;

	for (i = 1; i < argc; ++i) {
		char *argument = argv[i];

		if (argument[0] != '-')
			clar_usage(argv[0]);

		switch (argument[1]) {
		case 's': { /* given suite number, name, or prefix */
			int num = 0, offset = (argument[2] == '=') ? 3 : 2;
			int len = 0, is_num = 1, has_colon = 0, j;

			for (argument += offset; *argument; ++argument) {
				len++;
				if (*argument >= '0' && *argument <= '9')
					num = (num * 10) + (*argument - '0');
				else {
					is_num = 0;
					if (*argument == ':')
						has_colon = 1;
				}
			}

			argument = argv[i] + offset;

			if (!len)
				clar_usage(argv[0]);
			else if (is_num) {
				if ((size_t)num >= _clar_suite_count) {
					clar_print_onabort("Suite number %d does not exist.\n", num);
					exit(-1);
				}
				clar_run_suite(&_clar_suites[num]);
			}
			else if (!has_colon || argument[-1] == ':') {
				for (j = 0; j < (int)_clar_suite_count; ++j)
					if (strncmp(argument, _clar_suites[j].name, len) == 0)
						clar_run_suite(&_clar_suites[j]);
			}
			else {
				for (j = 0; j < (int)_clar_suite_count; ++j)
					if (strcmp(argument, _clar_suites[j].name) == 0) {
						clar_run_suite(&_clar_suites[j]);
						break;
					}
			}
			if (_clar.active_suite == NULL) {
				clar_print_onabort("No suite matching '%s' found.\n", argument);
				exit(-1);
			}
			break;
		}

		case 'q':
			_clar.report_errors_only = 1;
			break;

		case 'Q':
			_clar.exit_on_error = 1;
			break;

		case 'i': {
			int offset = (argument[2] == '=') ? 3 : 2;
			if (strcasecmp("all", argument + offset) == 0)
				clar_category_enable_all(_clar_suite_count, _clar_suites);
			else
				clar_category_enable(argument + offset);
			break;
		}

		case 'l': {
			size_t j;
			printf("Test suites (use -s<name> to run just one):\n");
			for (j = 0; j < _clar_suite_count; ++j)
				printf(" %3d: %s\n", (int)j, _clar_suites[j].name);

			printf("\nCategories (use -i<category> to include):\n");
			clar_category_enable_all(_clar_suite_count, _clar_suites);
			clar_category_print_enabled(" - ");

			exit(0);
		}

		default:
			clar_usage(argv[0]);
		}
	}
}

static int
clar_test(int argc, char **argv)
{
	clar_print_init(
		(int)_clar_callback_count,
		(int)_clar_suite_count,
		""
	);

	if (clar_sandbox() < 0) {
		clar_print_onabort("Failed to sandbox the test runner.\n");
		exit(-1);
	}

	clar_on_init();

	if (argc > 1)
		clar_parse_args(argc, argv);

	if (_clar.active_suite == NULL) {
		size_t i;
		for (i = 0; i < _clar_suite_count; ++i)
			clar_run_suite(&_clar_suites[i]);
	}

	clar_print_shutdown(
		_clar.test_count,
		(int)_clar_suite_count,
		_clar.total_errors
	);

	clar_on_shutdown();

	clar_unsandbox();
	return _clar.total_errors;
}

void
clar__assert(
	int condition,
	const char *file,
	int line,
	const char *error_msg,
	const char *description,
	int should_abort)
{
	struct clar_error *error;

	if (condition)
		return;

	error = calloc(1, sizeof(struct clar_error));

	if (_clar.errors == NULL)
		_clar.errors = error;

	if (_clar.last_error != NULL)
		_clar.last_error->next = error;

	_clar.last_error = error;

	error->test = _clar.active_test;
	error->test_number = _clar.test_count;
	error->suite = _clar.active_suite;
	error->file = file;
	error->line_number = line;
	error->error_msg = error_msg;

	if (description != NULL)
		error->description = strdup(description);

	_clar.suite_errors++;
	_clar.total_errors++;

	if (should_abort) {
		if (!_clar.trampoline_enabled) {
			clar_print_onabort(
				"Fatal error: a cleanup method raised an exception.");
			clar_report_errors();
			exit(-1);
		}

		longjmp(_clar.trampoline, -1);
	}
}

void clar__assert_equal_s(
	const char *s1,
	const char *s2,
	const char *file,
	int line,
	const char *err,
	int should_abort)
{
	int match = (s1 == NULL || s2 == NULL) ? (s1 == s2) : (strcmp(s1, s2) == 0);

	if (!match) {
		char buf[4096];
		snprint_eq(buf, 4096, "'%s' != '%s'", s1, s2);
		clar__assert(0, file, line, err, buf, should_abort);
	}
}

void clar__assert_equal_i(
	int i1,
	int i2,
	const char *file,
	int line,
	const char *err,
	int should_abort)
{
	if (i1 != i2) {
		char buf[128];
		snprint_eq(buf, 128, "%d != %d", i1, i2);
		clar__assert(0, file, line, err, buf, should_abort);
	}
}

void cl_set_cleanup(void (*cleanup)(void *), void *opaque)
{
	_clar.local_cleanup = cleanup;
	_clar.local_cleanup_payload = opaque;
}

static char _clar_path[4096];

static int
is_valid_tmp_path(const char *path)
{
	STAT_T st;

	if (stat(path, &st) != 0)
		return 0;

	if (!S_ISDIR(st.st_mode))
		return 0;

	return (access(path, W_OK) == 0);
}

static int
find_tmp_path(char *buffer, size_t length)
{
#ifndef _WIN32
	static const size_t var_count = 4;
	static const char *env_vars[] = {
		"TMPDIR", "TMP", "TEMP", "USERPROFILE"
 	};

 	size_t i;

	for (i = 0; i < var_count; ++i) {
		const char *env = getenv(env_vars[i]);
		if (!env)
			continue;

		if (is_valid_tmp_path(env)) {
			strncpy(buffer, env, length);
			return 0;
		}
	}

	/* If the environment doesn't say anything, try to use /tmp */
	if (is_valid_tmp_path("/tmp")) {
		strncpy(buffer, "/tmp", length);
		return 0;
	}

#else
	if (GetTempPath((DWORD)length, buffer))
		return 0;
#endif

	/* This system doesn't like us, try to use the current directory */
	if (is_valid_tmp_path(".")) {
		strncpy(buffer, ".", length);
		return 0;
	}

	return -1;
}

static void clar_unsandbox(void)
{
	if (_clar_path[0] == '\0')
		return;

#ifdef _WIN32
	chdir("..");
#endif

	fs_rm(_clar_path);
}

static int build_sandbox_path(void)
{
	const char path_tail[] = "clar_tmp_XXXXXX";
	size_t len;

	if (find_tmp_path(_clar_path, sizeof(_clar_path)) < 0)
		return -1;

	len = strlen(_clar_path);

#ifdef _WIN32
	{ /* normalize path to POSIX forward slashes */
		size_t i;
		for (i = 0; i < len; ++i) {
			if (_clar_path[i] == '\\')
				_clar_path[i] = '/';
		}
	}
#endif

	if (_clar_path[len - 1] != '/') {
		_clar_path[len++] = '/';
	}

	strncpy(_clar_path + len, path_tail, sizeof(_clar_path) - len);

#if defined(__MINGW32__)
	if (_mktemp(_clar_path) == NULL)
		return -1;

	if (mkdir(_clar_path, 0700) != 0)
		return -1;
#elif defined(_WIN32)
	if (_mktemp_s(_clar_path, sizeof(_clar_path)) != 0)
		return -1;

	if (mkdir(_clar_path, 0700) != 0)
		return -1;
#else
	if (mkdtemp(_clar_path) == NULL)
		return -1;
#endif

	return 0;
}

static int clar_sandbox(void)
{
	if (_clar_path[0] == '\0' && build_sandbox_path() < 0)
		return -1;

	if (chdir(_clar_path) != 0)
		return -1;

	return 0;
}


static const char *
fixture_path(const char *base, const char *fixture_name)
{
	static char _path[4096];
	size_t root_len;

	root_len = strlen(base);
	strncpy(_path, base, sizeof(_path));

	if (_path[root_len - 1] != '/')
		_path[root_len++] = '/';

	if (fixture_name[0] == '/')
		fixture_name++;

	strncpy(_path + root_len,
		fixture_name,
		sizeof(_path) - root_len);

	return _path;
}

#ifdef CLAR_FIXTURE_PATH
const char *cl_fixture(const char *fixture_name)
{
	return fixture_path(CLAR_FIXTURE_PATH, fixture_name);
}

void cl_fixture_sandbox(const char *fixture_name)
{
	fs_copy(cl_fixture(fixture_name), _clar_path);
}

void cl_fixture_cleanup(const char *fixture_name)
{
	fs_rm(fixture_path(_clar_path, fixture_name));
}
#endif

#ifdef _WIN32

#define RM_RETRY_COUNT	5
#define RM_RETRY_DELAY	10

#ifdef __MINGW32__

/* These security-enhanced functions are not available
 * in MinGW, so just use the vanilla ones */
#define wcscpy_s(a, b, c) wcscpy((a), (c))
#define wcscat_s(a, b, c) wcscat((a), (c))

#endif /* __MINGW32__ */

static int 
fs__dotordotdot(WCHAR *_tocheck)
{
	return _tocheck[0] == '.' &&
		(_tocheck[1] == '\0' ||
		 (_tocheck[1] == '.' && _tocheck[2] == '\0'));
}

static int
fs_rmdir_rmdir(WCHAR *_wpath)
{
	unsigned retries = 1;

	while (!RemoveDirectoryW(_wpath)) {
		/* Only retry when we have retries remaining, and the
		 * error was ERROR_DIR_NOT_EMPTY. */
		if (retries++ > RM_RETRY_COUNT ||
			ERROR_DIR_NOT_EMPTY != GetLastError())
			return -1;

		/* Give whatever has a handle to a child item some time
		 * to release it before trying again */
		Sleep(RM_RETRY_DELAY * retries * retries);
	}

	return 0;
}

static void
fs_rmdir_helper(WCHAR *_wsource)
{
	WCHAR buffer[MAX_PATH];
	HANDLE find_handle;
	WIN32_FIND_DATAW find_data;
	int buffer_prefix_len;

	/* Set up the buffer and capture the length */
	wcscpy_s(buffer, MAX_PATH, _wsource);
	wcscat_s(buffer, MAX_PATH, L"\\");
	buffer_prefix_len = wcslen(buffer);

	/* FindFirstFile needs a wildcard to match multiple items */
	wcscat_s(buffer, MAX_PATH, L"*");
	find_handle = FindFirstFileW(buffer, &find_data);
	cl_assert(INVALID_HANDLE_VALUE != find_handle);

	do {
		/* FindFirstFile/FindNextFile gives back . and ..
		 * entries at the beginning */
		if (fs__dotordotdot(find_data.cFileName))
			continue;

		wcscpy_s(buffer + buffer_prefix_len, MAX_PATH - buffer_prefix_len, find_data.cFileName);

		if (FILE_ATTRIBUTE_DIRECTORY & find_data.dwFileAttributes)
			fs_rmdir_helper(buffer);
		else {
			/* If set, the +R bit must be cleared before deleting */
			if (FILE_ATTRIBUTE_READONLY & find_data.dwFileAttributes)
				cl_assert(SetFileAttributesW(buffer, find_data.dwFileAttributes & ~FILE_ATTRIBUTE_READONLY));

			cl_assert(DeleteFileW(buffer));
		}
	}
	while (FindNextFileW(find_handle, &find_data));

	/* Ensure that we successfully completed the enumeration */
	cl_assert(ERROR_NO_MORE_FILES == GetLastError());

	/* Close the find handle */
	FindClose(find_handle);

	/* Now that the directory is empty, remove it */
	cl_assert(0 == fs_rmdir_rmdir(_wsource));
}

static int
fs_rm_wait(WCHAR *_wpath)
{
	unsigned retries = 1;
	DWORD last_error;

	do {
		if (INVALID_FILE_ATTRIBUTES == GetFileAttributesW(_wpath))
			last_error = GetLastError();
		else
			last_error = ERROR_SUCCESS;

		/* Is the item gone? */
		if (ERROR_FILE_NOT_FOUND == last_error ||
			ERROR_PATH_NOT_FOUND == last_error)
			return 0;

		Sleep(RM_RETRY_DELAY * retries * retries);	
	}
	while (retries++ <= RM_RETRY_COUNT);

	return -1;
}

static void
fs_rm(const char *_source)
{
	WCHAR wsource[MAX_PATH];
	DWORD attrs;

	/* The input path is UTF-8. Convert it to wide characters
	 * for use with the Windows API */
	cl_assert(MultiByteToWideChar(CP_UTF8,
				MB_ERR_INVALID_CHARS,
				_source,
				-1, /* Indicates NULL termination */
				wsource,
				MAX_PATH));

	/* Does the item exist? If not, we have no work to do */
	attrs = GetFileAttributesW(wsource);

	if (INVALID_FILE_ATTRIBUTES == attrs)
		return;

	if (FILE_ATTRIBUTE_DIRECTORY & attrs)
		fs_rmdir_helper(wsource);
	else {
		/* The item is a file. Strip the +R bit */
		if (FILE_ATTRIBUTE_READONLY & attrs)
			cl_assert(SetFileAttributesW(wsource, attrs & ~FILE_ATTRIBUTE_READONLY));

		cl_assert(DeleteFileW(wsource));
	}

	/* Wait for the DeleteFile or RemoveDirectory call to complete */
	cl_assert(0 == fs_rm_wait(wsource));
}

static void
fs_copydir_helper(WCHAR *_wsource, WCHAR *_wdest)
{
	WCHAR buf_source[MAX_PATH], buf_dest[MAX_PATH];
	HANDLE find_handle;
	WIN32_FIND_DATAW find_data;
	int buf_source_prefix_len, buf_dest_prefix_len;

	wcscpy_s(buf_source, MAX_PATH, _wsource);
	wcscat_s(buf_source, MAX_PATH, L"\\");
	buf_source_prefix_len = wcslen(buf_source);

	wcscpy_s(buf_dest, MAX_PATH, _wdest);
	wcscat_s(buf_dest, MAX_PATH, L"\\");
	buf_dest_prefix_len = wcslen(buf_dest);

	/* Get an enumerator for the items in the source. */
	wcscat_s(buf_source, MAX_PATH, L"*");
	find_handle = FindFirstFileW(buf_source, &find_data);
	cl_assert(INVALID_HANDLE_VALUE != find_handle);

	/* Create the target directory. */
	cl_assert(CreateDirectoryW(_wdest, NULL));

	do {
		/* FindFirstFile/FindNextFile gives back . and ..
		 * entries at the beginning */
		if (fs__dotordotdot(find_data.cFileName))
			continue;

		wcscpy_s(buf_source + buf_source_prefix_len, MAX_PATH - buf_source_prefix_len, find_data.cFileName);
		wcscpy_s(buf_dest + buf_dest_prefix_len, MAX_PATH - buf_dest_prefix_len, find_data.cFileName);

		if (FILE_ATTRIBUTE_DIRECTORY & find_data.dwFileAttributes)
			fs_copydir_helper(buf_source, buf_dest);
		else
			cl_assert(CopyFileW(buf_source, buf_dest, TRUE));
	}
	while (FindNextFileW(find_handle, &find_data));

	/* Ensure that we successfully completed the enumeration */
	cl_assert(ERROR_NO_MORE_FILES == GetLastError());

	/* Close the find handle */
	FindClose(find_handle);
}

static void
fs_copy(const char *_source, const char *_dest)
{
	WCHAR wsource[MAX_PATH], wdest[MAX_PATH];
	DWORD source_attrs, dest_attrs;
	HANDLE find_handle;
	WIN32_FIND_DATAW find_data;
	
	/* The input paths are UTF-8. Convert them to wide characters
	 * for use with the Windows API. */
	cl_assert(MultiByteToWideChar(CP_UTF8,
				MB_ERR_INVALID_CHARS,
				_source,
				-1,
				wsource,
				MAX_PATH));

	cl_assert(MultiByteToWideChar(CP_UTF8,
				MB_ERR_INVALID_CHARS,
				_dest,
				-1,
				wdest,
				MAX_PATH));

	/* Check the source for existence */
	source_attrs = GetFileAttributesW(wsource);
	cl_assert(INVALID_FILE_ATTRIBUTES != source_attrs);

	/* Check the target for existence */
	dest_attrs = GetFileAttributesW(wdest);

	if (INVALID_FILE_ATTRIBUTES != dest_attrs) {
		/* Target exists; append last path part of source to target.
		 * Use FindFirstFile to parse the path */
		find_handle = FindFirstFileW(wsource, &find_data);
		cl_assert(INVALID_HANDLE_VALUE != find_handle);
		wcscat_s(wdest, MAX_PATH, L"\\");
		wcscat_s(wdest, MAX_PATH, find_data.cFileName);
		FindClose(find_handle);

		/* Check the new target for existence */
		cl_assert(INVALID_FILE_ATTRIBUTES == GetFileAttributesW(wdest));
	}

	if (FILE_ATTRIBUTE_DIRECTORY & source_attrs)
		fs_copydir_helper(wsource, wdest);
	else
		cl_assert(CopyFileW(wsource, wdest, TRUE));
}

void
cl_fs_cleanup(void)
{
	fs_rm(fixture_path(_clar_path, "*"));
}

#else
static int
shell_out(char * const argv[])
{
	int status;
	pid_t pid;

	pid = fork();

	if (pid < 0) {
		fprintf(stderr,
			"System error: `fork()` call failed.\n");
		exit(-1);
	}

	if (pid == 0) {
		execv(argv[0], argv);
	}

	waitpid(pid, &status, 0);
	return WEXITSTATUS(status);
}

static void
fs_copy(const char *_source, const char *dest)
{
	char *argv[5];
	char *source;
	size_t source_len;

	source = strdup(_source);
	source_len = strlen(source);

	if (source[source_len - 1] == '/')
		source[source_len - 1] = 0;

	argv[0] = "/bin/cp";
	argv[1] = "-R";
	argv[2] = source;
	argv[3] = (char *)dest;
	argv[4] = NULL;

	cl_must_pass_(
		shell_out(argv),
		"Failed to copy test fixtures to sandbox"
	);

	free(source);
}

static void
fs_rm(const char *source)
{
	char *argv[4];

	argv[0] = "/bin/rm";
	argv[1] = "-Rf";
	argv[2] = (char *)source;
	argv[3] = NULL;

	cl_must_pass_(
		shell_out(argv),
		"Failed to cleanup the sandbox"
	);
}

void
cl_fs_cleanup(void)
{
	clar_unsandbox();
	clar_sandbox();
}
#endif

#define CLAR_CATEGORY_DEFAULT "default"

typedef struct {
	const char **names;
	int count;
	int alloc;
} clar_category_list;

static clar_category_list _clar_categorize_enabled;

static int clar_category_in_list(clar_category_list *list, const char *cat)
{
	int i;
	for (i = 0; i < list->count; ++i)
		if (strcasecmp(cat, list->names[i]) == 0)
			return 1;
	return 0;
}

static void clar_category_add_to_list(clar_category_list *list, const char *cat)
{
	if (clar_category_in_list(list, cat))
		return;

	if (list->count >= list->alloc) {
		list->alloc += 10;
		list->names = (const char **)realloc(
			(void *)list->names, list->alloc * sizeof(const char *));
	}

	list->names[list->count++] = cat;
}

static void clar_category_enable(const char *category)
{
	clar_category_add_to_list(&_clar_categorize_enabled, category);
}

static void clar_category_enable_all(size_t suite_count, const struct clar_suite *suites)
{
	size_t i;
	const char **cat;

	clar_category_enable(CLAR_CATEGORY_DEFAULT);

	for (i = 0; i < suite_count; i++)
		for (cat = suites[i].categories; cat && *cat; cat++)
			clar_category_enable(*cat);
}

static int _MAIN_CC clar_category_cmp(const void *a, const void *b)
{
	return - strcasecmp(a,b);
}

static void clar_category_print_enabled(const char *prefix)
{
	int i;

	qsort((void *)_clar_categorize_enabled.names,
		_clar_categorize_enabled.count,
		sizeof(const char *), clar_category_cmp);

	for (i = 0; i < _clar_categorize_enabled.count; ++i)
		printf("%s%s\n", prefix, _clar_categorize_enabled.names[i]);
}

static int clar_category_is_suite_enabled(const struct clar_suite *suite)
{
	const char **scan;

	if (!_clar_categorize_enabled.count)
		clar_category_enable(CLAR_CATEGORY_DEFAULT);

	if (!suite->categories)
		return clar_category_in_list(
			&_clar_categorize_enabled, CLAR_CATEGORY_DEFAULT);

	for (scan = suite->categories; *scan != NULL; scan++)
		if (clar_category_in_list(&_clar_categorize_enabled, *scan))
			return 1;

	return 0;
}


static void clar_print_init(int test_count, int suite_count, const char *suite_names)
{
	(void)test_count;
	printf("Loaded %d suites: %s\n", (int)suite_count, suite_names);
	printf("Started\n");
}

static void clar_print_shutdown(int test_count, int suite_count, int error_count)
{
	(void)test_count;
	(void)suite_count;
	(void)error_count;

	printf("\n\n");
	clar_report_errors();
}

static void clar_print_error(int num, const struct clar_error *error)
{
	printf("  %d) Failure:\n", num);

	printf("%s::%s (%s) [%s:%d] [-t%d]\n",
		error->suite,
		error->test,
		"no description",
		error->file,
		error->line_number,
		error->test_number);

	printf("  %s\n", error->error_msg);

	if (error->description != NULL)
		printf("  %s\n", error->description);

	printf("\n");
}

static void clar_print_ontest(const char *test_name, int test_number, int failed)
{
	(void)test_name;
	(void)test_number;
	printf("%c", failed ? 'F' : '.');
}

static void clar_print_onsuite(const char *suite_name, int suite_index)
{
	/* noop */
	(void)suite_index;
	(void)suite_name;
}

static void clar_print_onabort(const char *msg, ...)
{
	va_list argp;
	va_start(argp, msg);
	vfprintf(stderr, msg, argp);
	va_end(argp);
}


int _MAIN_CC main(int argc, char *argv[])
{
    return clar_test(argc, argv);
}
